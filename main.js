/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/act-goose.ts":
/*!**************************!*\
  !*** ./src/act-goose.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultActGooseState\": () => (/* binding */ createDefaultActGooseState),\n/* harmony export */   \"drawActGoose\": () => (/* binding */ drawActGoose),\n/* harmony export */   \"updateActGoose\": () => (/* binding */ updateActGoose)\n/* harmony export */ });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _bench__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bench */ \"./src/bench.ts\");\n/* harmony import */ var _dude__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dude */ \"./src/dude.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n\n\n\n\n\nconst GOOSE_WALK_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 2, 1), {\n    loop: true,\n    delay: 0.12,\n});\nconst GOOSE_SCREAM_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 3), {\n    loop: true,\n    delay: 0.5,\n});\nconst GOSLING_WALK_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 2, 1), {\n    delay: 0.12,\n    loop: true,\n});\nconst GOSLING_STAND_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 1));\nconst GOSLING_EATING_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 2, 3), {\n    loop: true,\n    delay: 0.6,\n});\nconst GOSLING_EATING_ANIMATION_ONCE = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 2, 3), {\n    delay: 0.6,\n});\nconst ZILLA_WALK_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(100, 80, 2, 1), {\n    loop: true,\n    delay: 0.2,\n});\nconst ZILLA_EATING_ANIMATION_ONCE = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(100, 80, 2, 3), {\n    delay: 0.6,\n});\nconst GOOSE_WALK_SPEED = 20;\nconst BREAD_FALL_SPEED = 70;\nconst CRUMB_FALL_SPEED = 30;\nconst ZILLA_WALK_SPEED = 30;\nconst BOY_VISION = 18;\nconst createDefaultMomState = () => ({\n    status: 'walking',\n    x: 100,\n    direction: -1,\n    animation: GOOSE_WALK_ANIMATION,\n});\nconst createDefaultKidsState = () => ({\n    kids: Array(2)\n        .fill(0)\n        .map((v, index) => ({\n        status: 'walking',\n        x: createDefaultMomState().x + 6 + index * 7,\n        animation: new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 2, 1), {\n            loop: true,\n            delay: 0.16,\n        }),\n    })),\n});\nconst createDefaultBoyState = () => ({\n    status: 'walking',\n    x: 140,\n    animation: new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 16, 2, 1), {\n        loop: true,\n        delay: 0.16,\n    }),\n    postStopTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(2),\n    crumbId: undefined,\n});\nconst createDefaultBreadState = () => ({\n    status: 'idle',\n    y: 22,\n    x: 69,\n});\nconst createDefaultCrumbState = () => ({\n    status: 'none',\n    crumbs: [],\n});\nconst createDefaultZillaState = () => ({\n    status: 'none',\n    x: 200,\n    animation: ZILLA_WALK_ANIMATION,\n    leaveTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(0.5),\n});\nconst END_TIME = 7;\nfunction createDefaultActGooseState() {\n    return {\n        status: 'active',\n        shake: false,\n        endTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(END_TIME),\n        dude: Object.assign(Object.assign({}, (0,_dude__WEBPACK_IMPORTED_MODULE_2__.createDefaultDudeState)()), { x: 30 }),\n        mom: createDefaultMomState(),\n        kids: createDefaultKidsState(),\n        boy: createDefaultBoyState(),\n        bread: createDefaultBreadState(),\n        crumb: createDefaultCrumbState(),\n        zilla: createDefaultZillaState(),\n    };\n}\nfunction drawMom(ctx, { state }) {\n    const { x, animation, status, direction } = state;\n    if (status === 'none') {\n        return;\n    }\n    if (status === 'walking' ||\n        status === 'walking-back' ||\n        status === 'walking-final') {\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.gooseWalk;\n        const rx = Math.round(x);\n        const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n        if (direction === 1) {\n            ctx.translate(rx + frameWidth / 2, 0);\n            ctx.scale(-1, 1);\n        }\n        const destX = direction === 1 ? 0 : rx - frameWidth / 2;\n        ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, destX, 27, frameWidth, frameHeight);\n        if (direction === 1) {\n            ctx.scale(-1, 1);\n            ctx.translate(-(rx + frameWidth / 2), 0);\n        }\n    }\n    if (status === 'screaming') {\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.gooseScream;\n        const rx = Math.round(x);\n        const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n        ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx, 27, frameWidth, frameHeight);\n    }\n}\nfunction updateMom({ state, deltaTime, }) {\n    let { status, animation, x, direction } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'walking') {\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        x -= xChange;\n        if (x < -20) {\n            status = 'walking-back';\n        }\n        animation.update(deltaTime);\n    }\n    if (status === 'walking-back') {\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        direction = 1;\n        x += xChange;\n        animation.update(deltaTime);\n        if (x >= 6) {\n            x = 1;\n            status = 'screaming';\n            animation = GOOSE_SCREAM_ANIMATION.reset();\n        }\n    }\n    if (status === 'walking-final') {\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n        if (x < -100) {\n            status = 'none';\n        }\n    }\n    if (status === 'screaming') {\n        animation.update(deltaTime);\n    }\n    return Object.assign(Object.assign({}, state), { x,\n        direction,\n        status });\n}\nfunction drawKids(ctx, { state }) {\n    const { kids } = state;\n    for (const kid of kids) {\n        const { x, animation } = kid;\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.goslingWalk;\n        const rx = Math.round(x);\n        const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n        ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, 27, frameWidth, frameHeight);\n    }\n}\nfunction updateKids({ state, deltaTime, }) {\n    let { kids } = state;\n    kids = kids.map((kid) => {\n        let { x, animation } = kid;\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n        return Object.assign(Object.assign({}, kid), { x });\n    });\n    return Object.assign(Object.assign({}, state), { kids });\n}\nfunction drawBoy(ctx, { state }) {\n    const { status, x, animation } = state;\n    if (status === 'none') {\n        return;\n    }\n    const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.goslingWalk;\n    const rx = Math.round(x);\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, 27, frameWidth, frameHeight);\n}\nfunction updateBoy({ state, deltaTime, crumbState, }) {\n    let { status, animation, x, postStopTimer, crumbId } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'walking' && crumbId == null) {\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n        if (x <= 77) {\n            status = 'stop';\n            animation = GOSLING_STAND_ANIMATION.reset();\n        }\n    }\n    if (status === 'stop') {\n        postStopTimer.update(deltaTime);\n        if (postStopTimer.isDone()) {\n            status = 'eating';\n            animation = GOSLING_EATING_ANIMATION.reset();\n        }\n    }\n    if (status === 'eating' && crumbId == null) {\n        animation.update(deltaTime);\n    }\n    if (status === 'waiting' && crumbId == null) {\n        let closestIndex = -1;\n        let closestDistance = Infinity;\n        for (const [index, crumb] of crumbState.crumbs.entries()) {\n            if (crumb.x >= x - BOY_VISION && crumb.x <= x + BOY_VISION) {\n                const distance = Math.abs(x - crumb.x);\n                if (distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIndex = index;\n                }\n            }\n        }\n        const crumbInVision = crumbState.crumbs[closestIndex];\n        if (crumbInVision) {\n            crumbId = crumbInVision.id;\n            status = 'walking';\n            animation = GOSLING_WALK_ANIMATION.reset();\n        }\n    }\n    if (status === 'walking' && crumbId != null) {\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        const rx = Math.round(x);\n        const eatX = x - 4;\n        animation.update(deltaTime);\n        const crumb = crumbState.crumbs.find((c) => c.id === crumbId);\n        if (crumb.x < eatX) {\n            x -= xChange;\n        }\n        else if (crumb.x > eatX) {\n            x += xChange;\n        }\n        if (Math.abs(crumb.x - eatX) <= 1) {\n            x = crumb.x + 4;\n            status = 'eating';\n            animation = GOSLING_EATING_ANIMATION_ONCE.reset();\n        }\n    }\n    if (status === 'eating' && crumbId != null) {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            const crumb = crumbState.crumbs.find((c) => c.id === crumbId);\n            crumb.shouldRemove = true;\n            status = 'waiting';\n            animation = GOSLING_STAND_ANIMATION.reset();\n            crumbId = null;\n        }\n    }\n    if (status === 'walking-final') {\n        const xChange = GOOSE_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n        if (x < -100) {\n            status = 'none';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { x,\n        status,\n        animation,\n        crumbId });\n}\nfunction drawBread(ctx, { state, dude }) {\n    const { status, x, y } = state;\n    if (status === 'none') {\n        return;\n    }\n    const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.bread;\n    const rx = Math.round(x);\n    const ry = Math.round(y);\n    if (status === 'idle') {\n        ctx.drawImage(image, 0, 4, 15, 3, rx - 10, ry + 10, 15, 3);\n    }\n    if (status === 'falling') {\n        ctx.drawImage(image, 0, 4, 15, 3, rx - 10, ry + 10, 15, 3);\n        // ctx.drawImage(image, 0, 8, 8, 12, rx, ry + 12, 8, 12);\n    }\n    if (status === 'laying') {\n        ctx.drawImage(image, 0, 0, 15, 3, rx - 10, ry + 10, 15, 3);\n    }\n    if (status === 'dude') {\n        const dudeRx = Math.round(dude.x);\n        const rx = dude.direction === 1 ? dudeRx + 10 : dudeRx - 10;\n        const frameWidth = 10;\n        if (dude.direction === -1) {\n            ctx.translate(Math.round(rx + frameWidth / 2), 0);\n            ctx.scale(-1, 1);\n        }\n        const destX = dude.direction === -1 ? 0 : Math.round(rx - frameWidth / 2);\n        ctx.drawImage(image, 0, 0, frameWidth, 3, destX, 26, frameWidth, 3);\n        if (dude.direction === -1) {\n            ctx.scale(-1, 1);\n            ctx.translate(-Math.round(rx + frameWidth / 2), 0);\n        }\n    }\n}\nfunction updateBread({ state, deltaTime, }) {\n    let { status, x, y } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'falling') {\n        const yChange = BREAD_FALL_SPEED * deltaTime;\n        y += yChange;\n        if (y >= 30) {\n            y = 30;\n            status = 'laying';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { y,\n        status });\n}\nfunction drawCrumb(ctx, { state }) {\n    const { crumbs } = state;\n    for (const crumb of crumbs) {\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_5__.COLOR.A;\n        ctx.fillRect(Math.round(crumb.x), Math.round(crumb.y), 1, 1);\n    }\n}\nfunction updateCrumb({ state, deltaTime, dude, }) {\n    let { crumbs, status } = state;\n    if (status === 'none') {\n        return state;\n    }\n    crumbs = crumbs.map((crumb) => {\n        let { y } = crumb;\n        const yChange = CRUMB_FALL_SPEED * deltaTime;\n        y += yChange;\n        if (y >= 42) {\n            y = 42;\n        }\n        return Object.assign(Object.assign({}, crumb), { y });\n    });\n    crumbs = crumbs.filter((c) => !c.shouldRemove);\n    const maxId = Math.max(...crumbs.map((c) => c.id), 0);\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Down);\n    const anyFalling = crumbs.some((crumb) => crumb.y < 42);\n    if (!anyFalling && isDown) {\n        crumbs = [\n            ...crumbs,\n            {\n                x: dude.direction === 1 ? dude.x + 13 : dude.x - 13,\n                y: 28,\n                id: maxId + 1,\n                shouldRemove: false,\n            },\n        ];\n    }\n    return Object.assign(Object.assign({}, state), { crumbs });\n}\nfunction drawZilla(ctx, { state }) {\n    const { x, animation } = state;\n    const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.gosilla;\n    const rx = Math.round(x);\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, -32, frameWidth, frameHeight);\n}\nfunction updateZilla({ state, deltaTime, }) {\n    let { status, animation, x } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'walking') {\n        const xChange = ZILLA_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n    }\n    if (status === 'eating') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            status = 'walking-out';\n            animation = ZILLA_WALK_ANIMATION.reset();\n        }\n    }\n    if (status === 'walking-out') {\n        const xChange = ZILLA_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n    }\n    return Object.assign(Object.assign({}, state), { x,\n        status,\n        animation });\n}\nfunction drawActGoose(ctx, { state, lastTime }) {\n    (0,_bench__WEBPACK_IMPORTED_MODULE_1__.drawBench)(ctx);\n    (0,_dude__WEBPACK_IMPORTED_MODULE_2__.drawDude)(ctx, { state: state.dude, lastTime });\n    drawMom(ctx, { state: state.mom });\n    drawKids(ctx, { state: state.kids });\n    drawBoy(ctx, { state: state.boy });\n    drawBread(ctx, { state: state.bread, dude: state.dude });\n    drawCrumb(ctx, { state: state.crumb });\n    drawZilla(ctx, { state: state.zilla });\n}\nfunction updateActGoose({ state, deltaTime, }) {\n    let { dude, mom, kids, boy, bread, crumb, zilla, endTimer, status, shake } = state;\n    dude = (0,_dude__WEBPACK_IMPORTED_MODULE_2__.updateDude)({ state: dude, deltaTime });\n    mom = updateMom({ state: mom, deltaTime });\n    kids = updateKids({ state: kids, deltaTime });\n    boy = updateBoy({ state: boy, deltaTime, crumbState: crumb });\n    bread = updateBread({ state: bread, deltaTime });\n    crumb = updateCrumb({ state: crumb, deltaTime, dude });\n    zilla = updateZilla({ state: zilla, deltaTime });\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Up);\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Down);\n    if (mom.x <= 44 && bread.status === 'idle') {\n        bread.status = 'falling';\n    }\n    const isBreadRange = dude.direction === 1\n        ? dude.x >= 55 && dude.x <= 70\n        : dude.x >= 60 && dude.x <= 74;\n    if (bread.status === 'laying' &&\n        (dude.status === 'idle' || dude.status === 'walking') &&\n        isDown &&\n        isBreadRange) {\n        dude.status = 'crouch';\n    }\n    if (bread.status === 'laying' &&\n        dude.status === 'crouch' &&\n        isUp &&\n        isBreadRange) {\n        dude.status = 'idle';\n        dude.hand = 'holding-down';\n        bread.status = 'dude';\n    }\n    if (bread.status === 'dude' && crumb.status !== 'active') {\n        boy.status = 'waiting';\n        boy.animation = GOSLING_STAND_ANIMATION.reset();\n        crumb.status = 'active';\n    }\n    if (boy.x < 19 && mom.status === 'screaming') {\n        mom.status = 'walking-final';\n        mom.animation = GOOSE_WALK_ANIMATION.reset();\n        mom.direction = -1;\n        boy.status = 'walking-final';\n        boy.animation = GOSLING_WALK_ANIMATION.reset();\n    }\n    if (boy.x < -30 && zilla.status === 'none') {\n        zilla.status = 'walking';\n        dude.status = 'idle';\n        dude.walking = 'blocked';\n        shake = true;\n    }\n    if (zilla.status === 'walking' && zilla.x - 22 <= dude.x) {\n        shake = false;\n        zilla.status = 'eating';\n        zilla.animation = ZILLA_EATING_ANIMATION_ONCE.reset();\n    }\n    if (zilla.status === 'eating' && zilla.animation.index() === 1) {\n        dude.status = 'none';\n        bread.status = 'none';\n        endTimer.update(deltaTime);\n    }\n    if (zilla.status === 'walking-out') {\n        zilla.leaveTimer.update(deltaTime);\n        if (zilla.leaveTimer.isDone()) {\n            shake = true;\n        }\n    }\n    if (endTimer.timeLeft < END_TIME) {\n        endTimer.update(deltaTime);\n        if (endTimer.isDone()) {\n            shake = false;\n            status = 'ended';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { dude,\n        mom,\n        kids,\n        boy,\n        bread,\n        crumb,\n        zilla,\n        endTimer,\n        status,\n        shake });\n}\n\n\n//# sourceURL=webpack:///./src/act-goose.ts?");

/***/ }),

/***/ "./src/act-intro.ts":
/*!**************************!*\
  !*** ./src/act-intro.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultActIntroState\": () => (/* binding */ createDefaultActIntroState),\n/* harmony export */   \"drawActIntro\": () => (/* binding */ drawActIntro),\n/* harmony export */   \"updateActIntro\": () => (/* binding */ updateActIntro)\n/* harmony export */ });\n/* harmony import */ var _bench__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bench */ \"./src/bench.ts\");\n/* harmony import */ var _dude__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dude */ \"./src/dude.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n\n\n\n\n\nconst PUNK_WALK_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_4__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_4__.createSheet)(12, 32, 3), {\n    loop: true,\n    delay: 0.2,\n});\nconst PUNK_LISTEN_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_4__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_4__.createSheet)(24, 32, 2), {\n    loop: true,\n    delay: 0.2,\n});\nconst PUNK_HANDING_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_4__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_4__.createSheet)(24, 32, 2, 2), {\n    loop: true,\n    delay: 0.2,\n});\nconst PUNK_WALK_SPEED = 6;\nconst NOTE_SPEED = 4;\nconst createDefaultArrowState = () => ({ status: 'walk' });\nconst createDefaultPunkState = () => ({\n    status: 'off',\n    x: -15,\n    direction: 1,\n    animation: PUNK_WALK_ANIMATION.reset(),\n});\nconst createDefaultNoteState = () => ({\n    status: 'none',\n    backwards: false,\n    x: 10,\n});\nconst createDefaultDudeSuckedState = () => ({\n    status: 'none',\n    animation: new _animation__WEBPACK_IMPORTED_MODULE_4__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_4__.createSheet)(16, 32, 11), { delay: 0.3 }),\n    timer: new _animation__WEBPACK_IMPORTED_MODULE_4__.Timer(4),\n});\nfunction createDefaultActIntroState() {\n    return {\n        status: 'active',\n        shake: false,\n        endTimer: new _animation__WEBPACK_IMPORTED_MODULE_4__.Timer(3),\n        bobbingTimer: new _animation__WEBPACK_IMPORTED_MODULE_4__.Timer(2),\n        dude: Object.assign(Object.assign({}, (0,_dude__WEBPACK_IMPORTED_MODULE_1__.createDefaultDudeState)()), { x: 18 }),\n        dudeSucked: createDefaultDudeSuckedState(),\n        arrow: createDefaultArrowState(),\n        punk: createDefaultPunkState(),\n        note: createDefaultNoteState(),\n    };\n}\nfunction drawActIntro(ctx, { state, lastTime }) {\n    (0,_bench__WEBPACK_IMPORTED_MODULE_0__.drawBench)(ctx);\n    drawArrow(ctx, { state: state.arrow, lastTime });\n    drawPunk(ctx, { state: state.punk });\n    drawNote(ctx, { state: state.note });\n    (0,_dude__WEBPACK_IMPORTED_MODULE_1__.drawDude)(ctx, { state: state.dude, lastTime });\n    drawDudeSucked(ctx, { state: state.dudeSucked });\n}\nfunction drawArrow(ctx, { state, lastTime }) {\n    const { status } = state;\n    const image = _deps__WEBPACK_IMPORTED_MODULE_2__.resources.images.arrows;\n    const w = 6;\n    const h = 6;\n    if (status === 'walk') {\n        if (Math.round(lastTime / 0.5) % 2 === 0) {\n            ctx.drawImage(image, 0, 0, w, h, 10, 5, w, h);\n            ctx.drawImage(image, 7, 0, w, h, 20, 5, w, h);\n        }\n    }\n    if (status === 'sit') {\n        if (Math.round(lastTime / 0.5) % 2 === 0) {\n            ctx.drawImage(image, 7, 6, w, h, 54, 10, w, h);\n            ctx.drawImage(image, 0, 6, w, h, 54, 2, w, h);\n        }\n    }\n}\nfunction drawDudeSucked(ctx, { state }) {\n    const { status, animation } = state;\n    if (status === 'none' || status === 'timer' || status === 'done') {\n        return;\n    }\n    const image = _deps__WEBPACK_IMPORTED_MODULE_2__.resources.images.dudeSucked;\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, 25, 10, frameWidth, frameHeight);\n}\nfunction updateDudeSucked({ state, deltaTime, }) {\n    let { status, timer, animation } = state;\n    if (status === 'none' || status === 'done') {\n        return state;\n    }\n    if (status === 'timer') {\n        timer.update(deltaTime);\n        if (timer.isDone()) {\n            status = 'active';\n        }\n    }\n    if (status === 'active') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            status = 'done';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { status });\n}\nfunction drawPunk(ctx, { state }) {\n    const { x, direction, animation, status } = state;\n    const rx = Math.round(x);\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    let image;\n    let destX = direction === -1 ? 0 : rx - frameWidth / 2;\n    if (status === 'walk-in' || status === 'walk-out' || status === 'off') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_2__.resources.images.punkWalk;\n    }\n    else if (status === 'listen' ||\n        status === 'handing' ||\n        status === 'listen-end') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_2__.resources.images.punkListen;\n        destX += 6;\n    }\n    if (direction === -1) {\n        ctx.translate(rx + frameWidth / 2, 0);\n        ctx.scale(-1, 1);\n    }\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, destX, 13, frameWidth, frameHeight);\n    if (direction === -1) {\n        ctx.scale(-1, 1);\n        ctx.translate(-(rx + frameWidth / 2), 0);\n    }\n}\nfunction updatePunk({ state, deltaTime, }) {\n    let { x, direction, status, animation } = state;\n    const xChange = PUNK_WALK_SPEED * deltaTime;\n    if (status === 'walk-in') {\n        x += xChange;\n        direction = 1;\n        animation.update(deltaTime);\n        if (x >= 15) {\n            status = 'listen';\n            animation = PUNK_LISTEN_ANIMATION.reset();\n        }\n    }\n    if (status === 'walk-out') {\n        if (animation !== PUNK_WALK_ANIMATION) {\n            animation = PUNK_WALK_ANIMATION.reset();\n        }\n        x -= xChange;\n        direction = -1;\n        animation.update(deltaTime);\n        if (x < createDefaultPunkState().x) {\n            x = createDefaultPunkState().x;\n            direction = 1;\n            status = 'off';\n        }\n    }\n    if (status === 'listen') {\n        animation.update(deltaTime);\n    }\n    if (status === 'handing') {\n        animation.update(deltaTime);\n    }\n    if (status === 'listen-end') {\n        animation.update(deltaTime);\n    }\n    return Object.assign(Object.assign({}, state), { x,\n        status,\n        direction,\n        animation });\n}\nfunction drawNote(ctx, { state }) {\n    const { x, status } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    const image = _deps__WEBPACK_IMPORTED_MODULE_2__.resources.images.punkNotes;\n    const step = 8;\n    const baseY = 5;\n    function drawOne(x) {\n        const yOff = x % 3;\n        if (x < 18)\n            return;\n        ctx.drawImage(image, 1, 1, 4, 6, x, baseY + yOff, 4, 6);\n    }\n    function drawTwo(x) {\n        const yOff = x % 3;\n        if (x < 18)\n            return;\n        ctx.drawImage(image, 6, 1, 4, 6, x, baseY + yOff, 4, 6);\n    }\n    function drawThree(x) {\n        const yOff = x % 3;\n        if (x < 18)\n            return;\n        ctx.drawImage(image, 11, 1, 4, 6, x, baseY + yOff, 4, 6);\n    }\n    for (let i = 0; i < 33; i++) {\n        const index = i % 3;\n        const rstep = step * i;\n        if (rx > rstep) {\n            index === 0 && drawOne(rx - rstep);\n            index === 1 && drawTwo(rx - rstep);\n            index === 2 && drawThree(rx - rstep);\n        }\n    }\n}\nfunction updateNote({ state, deltaTime, }) {\n    let { x, status, backwards } = state;\n    if (status === 'none') {\n        return state;\n    }\n    let xChange = NOTE_SPEED * deltaTime;\n    if (backwards) {\n        xChange *= -4;\n    }\n    x += xChange;\n    if (x > _config__WEBPACK_IMPORTED_MODULE_5__.OW * 3) {\n        x = _config__WEBPACK_IMPORTED_MODULE_5__.OW + (x - _config__WEBPACK_IMPORTED_MODULE_5__.OW * 3);\n    }\n    return Object.assign(Object.assign({}, state), { x });\n}\nfunction updateActIntro({ state, deltaTime, }) {\n    let { status, dude, arrow, punk, note, dudeSucked, endTimer, bobbingTimer } = state;\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_2__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up);\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_2__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down);\n    dude = (0,_dude__WEBPACK_IMPORTED_MODULE_1__.updateDude)({ state: dude, deltaTime });\n    punk = updatePunk({ state: punk, deltaTime });\n    note = updateNote({ state: note, deltaTime });\n    dudeSucked = updateDudeSucked({ state: dudeSucked, deltaTime });\n    if (dude.x !== state.dude.x && arrow.status === 'walk') {\n        arrow.status = 'sit';\n    }\n    const isSittingRange = dude.x >= 47 && dude.x < 64;\n    if (isDown && isSittingRange) {\n        arrow.status = 'none';\n        dude.status = 'sitting';\n        punk.status = 'walk-in';\n    }\n    if (dude.status === 'sitting' && isUp) {\n        dude.status = 'walking';\n        if (dude.head !== 'bobbing') {\n            punk.status = 'walk-out';\n            note = createDefaultNoteState();\n        }\n    }\n    if (punk.status === 'listen') {\n        note.status = 'playing';\n    }\n    if (note.x > dude.x && dude.status !== 'none') {\n        dude.head = 'bobbing';\n    }\n    if (dude.head === 'bobbing' && dude.status !== 'none') {\n        bobbingTimer.update(deltaTime);\n        if (bobbingTimer.isDone() && punk.status !== 'handing') {\n            punk.status = 'handing';\n            punk.animation = PUNK_HANDING_ANIMATION.reset();\n        }\n        if (punk.status === 'handing') {\n            if (dude.x < 32) {\n                dude.x = 32;\n                dude.hand = 'holding-down';\n                dude.status = 'idle';\n                dude.walking = 'blocked';\n                dudeSucked.status = 'timer';\n            }\n            if (dudeSucked.status === 'active') {\n                note.backwards = true;\n                dude.status = 'none';\n                dude.head = 'static';\n            }\n        }\n    }\n    if (dudeSucked.status === 'done' && punk.status !== 'listen-end') {\n        punk.status = 'listen-end';\n        punk.animation = PUNK_LISTEN_ANIMATION.reset();\n        note.status = 'none';\n    }\n    if (punk.status === 'listen-end') {\n        endTimer.update(deltaTime);\n        if (endTimer.isDone()) {\n            status = 'ended';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { status,\n        dude,\n        arrow,\n        punk,\n        dudeSucked,\n        note,\n        endTimer });\n}\n\n\n//# sourceURL=webpack:///./src/act-intro.ts?");

/***/ }),

/***/ "./src/act-null.ts":
/*!*************************!*\
  !*** ./src/act-null.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultActNull\": () => (/* binding */ defaultActNull)\n/* harmony export */ });\nconst defaultActNull = { status: 'ended', shake: false };\n\n\n//# sourceURL=webpack:///./src/act-null.ts?");

/***/ }),

/***/ "./src/act-outro.ts":
/*!**************************!*\
  !*** ./src/act-outro.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultActOutroState\": () => (/* binding */ createDefaultActOutroState),\n/* harmony export */   \"drawActOutro\": () => (/* binding */ drawActOutro),\n/* harmony export */   \"updateActOutro\": () => (/* binding */ updateActOutro)\n/* harmony export */ });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _dude__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dude */ \"./src/dude.ts\");\n/* harmony import */ var _bench__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bench */ \"./src/bench.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n\n\n\n\n\nconst MIDGET_WALK_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 3), {\n    loop: true,\n    delay: 0.12,\n});\nconst MIDGET_CLIMB_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 2), {\n    loop: true,\n    delay: 0.4,\n});\nconst MIDGET_CLIMB_SPEED = 6;\nconst MIDGET_WALK_SPEED = 10;\nconst MANHOLE_APPEAR_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 8, 6).reverse(), {\n    delay: 0.3,\n});\nconst MANHOLE_DISAPPEAR_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 8, 6), {\n    delay: 0.3,\n});\nlet offCanvas;\nif (window.OffscreenCanvas) {\n    offCanvas = new OffscreenCanvas(_config__WEBPACK_IMPORTED_MODULE_5__.IW, _config__WEBPACK_IMPORTED_MODULE_5__.IH);\n}\nelse {\n    offCanvas = document.createElement('canvas');\n    offCanvas.width = _config__WEBPACK_IMPORTED_MODULE_5__.IW;\n    offCanvas.height = _config__WEBPACK_IMPORTED_MODULE_5__.IH;\n}\nconst offCtx = offCanvas.getContext('2d');\noffCtx.imageSmoothingEnabled = false;\nconst createDefaultMidgetState = () => ({\n    status: 'none',\n    x: 5,\n    y: 40,\n    animation: MIDGET_CLIMB_ANIMATION,\n});\nconst createDefaultManholeState = () => ({\n    status: 'idle',\n    animation: MANHOLE_APPEAR_ANIMATION,\n    appearTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(0),\n});\nconst END_TIME = 3;\nfunction createDefaultActOutroState() {\n    return {\n        status: 'active',\n        shake: false,\n        endTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(END_TIME),\n        dude: Object.assign(Object.assign({}, (0,_dude__WEBPACK_IMPORTED_MODULE_1__.createDefaultDudeState)()), { x: 63, status: 'sitting', direction: -1 }),\n        clone: Object.assign(Object.assign({}, (0,_dude__WEBPACK_IMPORTED_MODULE_1__.createDefaultDudeState)()), { x: 63, status: 'sitting', direction: -1, controllable: false, isUnderworld: true }),\n        midget: createDefaultMidgetState(),\n        manhole: createDefaultManholeState(),\n        isUnderworld: false,\n    };\n}\nfunction drawManhole(ctx, { state }) {\n    const { status, animation } = state;\n    if (status === 'none') {\n        return;\n    }\n    if (status === 'appear' || status === 'disappear') {\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.manholeAppear;\n        const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n        ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, 5, 35, frameWidth, frameHeight);\n    }\n    if (status === 'full') {\n        ctx.drawImage(_deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.manhole, 0, 0, 16, 8, 5, 35, 16, 8);\n    }\n}\nfunction updateManhole({ state, deltaTime, }) {\n    let { status, animation, appearTimer } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'idle') {\n        appearTimer.update(deltaTime);\n        if (appearTimer.isDone()) {\n            status = 'appear';\n        }\n    }\n    if (status === 'appear') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            status = 'full';\n        }\n    }\n    if (status === 'disappear') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            status = 'none';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { status, appearTimer });\n}\nfunction drawUnderworldLadder(ctx) {\n    ctx.drawImage(_deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.manhole, 0, 0, 16, 50, 5, -10, 16, 50);\n}\nfunction drawUnderworldBackground(ctx) {\n    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_5__.COLOR.A;\n    ctx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_5__.OW, _config__WEBPACK_IMPORTED_MODULE_5__.OH);\n}\nfunction drawSneakyPatch(ctx) {\n    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_5__.COLOR.B;\n    ctx.fillRect(0, 43, _config__WEBPACK_IMPORTED_MODULE_5__.OW, _config__WEBPACK_IMPORTED_MODULE_5__.OH);\n}\nfunction drawTree(ctx) {\n    ctx.drawImage(_deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.tree, 0, 0, 64, 48, 56, -2, 54, 48);\n}\nfunction drawWithSwappedFill(ctx, drawFn) {\n    offCtx.globalCompositeOperation = 'source-over';\n    offCtx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_5__.OW, _config__WEBPACK_IMPORTED_MODULE_5__.OH);\n    drawFn(offCtx);\n    offCtx.globalCompositeOperation = 'source-atop';\n    offCtx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_5__.COLOR.B;\n    offCtx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_5__.OW, _config__WEBPACK_IMPORTED_MODULE_5__.OH);\n    offCtx.globalCompositeOperation = 'source-over';\n    ctx.drawImage(offCanvas, 0, 0);\n}\nfunction drawMidget(ctx, { state }) {\n    const { x, y, animation, status } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    const ry = Math.round(y);\n    let image;\n    if (status === 'climb') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.midgetClimb;\n    }\n    else {\n        image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.midgetWalk;\n    }\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx, ry, frameWidth, frameHeight);\n}\nfunction updateMidget({ state, deltaTime, }) {\n    let { x, y, status, animation } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'climb') {\n        animation.update(deltaTime);\n        const yChange = MIDGET_CLIMB_SPEED * deltaTime;\n        y -= yChange;\n        if (y <= 11) {\n            y = 11;\n            status = 'walking';\n            animation = MIDGET_WALK_ANIMATION;\n        }\n    }\n    if (status === 'walking') {\n        const xChange = MIDGET_WALK_SPEED * deltaTime;\n        x -= xChange;\n        animation.update(deltaTime);\n        if (x < -10) {\n            status = 'none';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { x,\n        y,\n        status,\n        animation });\n}\nfunction drawActOutro(ctx, { state, lastTime }) {\n    const { isUnderworld } = state;\n    if (isUnderworld) {\n        drawUnderworldBackground(ctx);\n        drawWithSwappedFill(ctx, (otherCtx) => (0,_bench__WEBPACK_IMPORTED_MODULE_2__.drawBench)(otherCtx));\n        drawWithSwappedFill(ctx, (otherCtx) => drawUnderworldLadder(otherCtx));\n        drawWithSwappedFill(ctx, (otherCtx) => {\n            (0,_dude__WEBPACK_IMPORTED_MODULE_1__.drawDude)(otherCtx, { state: state.dude, lastTime });\n        });\n        drawWithSwappedFill(ctx, (otherCtx) => {\n            (0,_dude__WEBPACK_IMPORTED_MODULE_1__.drawDude)(otherCtx, { state: state.clone, lastTime });\n        });\n        drawWithSwappedFill(ctx, (otherCtx) => {\n            drawTree(otherCtx);\n        });\n    }\n    else {\n        (0,_bench__WEBPACK_IMPORTED_MODULE_2__.drawBench)(ctx);\n        drawMidget(ctx, { state: state.midget });\n        if (state.dude.controllable) {\n            (0,_dude__WEBPACK_IMPORTED_MODULE_1__.drawDude)(ctx, { state: state.dude, lastTime });\n        }\n        else {\n            (0,_dude__WEBPACK_IMPORTED_MODULE_1__.drawDude)(ctx, { state: state.clone, lastTime });\n        }\n        drawManhole(ctx, { state: state.manhole });\n        drawSneakyPatch(ctx);\n    }\n}\nfunction updateActOutro({ state, deltaTime, }) {\n    let { isUnderworld, dude, clone, midget, manhole, status, endTimer } = state;\n    dude = (0,_dude__WEBPACK_IMPORTED_MODULE_1__.updateDude)({ state: dude, deltaTime });\n    clone = (0,_dude__WEBPACK_IMPORTED_MODULE_1__.updateDude)({ state: clone, deltaTime });\n    midget = updateMidget({ state: midget, deltaTime });\n    manhole = updateManhole({ state: manhole, deltaTime });\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Up);\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Down);\n    if (manhole.status === 'appear') {\n        midget.status = 'climb';\n    }\n    if (dude.status === 'sitting' && dude.controllable && isUp) {\n        dude.status = 'idle';\n    }\n    const active = () => (dude.controllable ? dude : clone);\n    const isManholeRange = active().x >= 8 && active().x <= 18;\n    if (isDown &&\n        isManholeRange &&\n        active().status !== 'climb' &&\n        manhole.status === 'full') {\n        active().status = 'climb';\n    }\n    if (isUp &&\n        isManholeRange &&\n        active().status !== 'climb' &&\n        manhole.status === 'full' &&\n        isUnderworld) {\n        active().status = 'climb';\n    }\n    if (active().y < -20 && isUnderworld) {\n        isUnderworld = false;\n        active().isUnderworld = false;\n        active().y = 40;\n    }\n    if (active().y > 40 && !isUnderworld) {\n        isUnderworld = true;\n        active().isUnderworld = true;\n        active().y = -20;\n    }\n    if (isUnderworld) {\n        const isSittingRange = dude.x >= 47 && dude.x < 54;\n        if ((dude.status === 'walking' || dude.status === 'idle') &&\n            isDown &&\n            isSittingRange) {\n            dude.status = 'sitting';\n            dude.controllable = false;\n            clone.controllable = true;\n        }\n        if (clone.status === 'sitting' && isUp) {\n            clone.status = 'idle';\n        }\n    }\n    if (!clone.isUnderworld &&\n        clone.status !== 'climb' &&\n        manhole.status === 'full') {\n        manhole.status = 'disappear';\n        manhole.animation = MANHOLE_DISAPPEAR_ANIMATION.reset();\n    }\n    const isSittingRange = clone.x >= 47 && clone.x < 65;\n    if (!clone.isUnderworld &&\n        isSittingRange &&\n        isDown &&\n        clone.status !== 'sitting') {\n        clone.status = 'sitting';\n        clone.controllable = false;\n        endTimer.update(deltaTime);\n    }\n    if (endTimer.timeLeft < END_TIME) {\n        endTimer.update(deltaTime);\n        if (endTimer.isDone()) {\n            status = 'ended';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { dude,\n        clone,\n        midget,\n        manhole,\n        status,\n        endTimer,\n        isUnderworld });\n}\n\n\n//# sourceURL=webpack:///./src/act-outro.ts?");

/***/ }),

/***/ "./src/act-rain.ts":
/*!*************************!*\
  !*** ./src/act-rain.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultActRainState\": () => (/* binding */ createDefaultActRainState),\n/* harmony export */   \"createDefaultGhostState\": () => (/* binding */ createDefaultGhostState),\n/* harmony export */   \"createDefaultRainSate\": () => (/* binding */ createDefaultRainSate),\n/* harmony export */   \"createDefaultUmbrellaState\": () => (/* binding */ createDefaultUmbrellaState),\n/* harmony export */   \"createDudeDisappearState\": () => (/* binding */ createDudeDisappearState),\n/* harmony export */   \"drawActRain\": () => (/* binding */ drawActRain),\n/* harmony export */   \"updateActRain\": () => (/* binding */ updateActRain)\n/* harmony export */ });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _bench__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bench */ \"./src/bench.ts\");\n/* harmony import */ var _dude__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dude */ \"./src/dude.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\n\n\n\n\nconst GHOST_STAND_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 24, 1));\nconst GHOST_APPEAR_ANIMATION_SLOW = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 24, 9).reverse(), { delay: 0.5 });\nconst GHOST_APPEAR_ANIMATION_ = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 24, 9).reverse(), {\n    delay: 0.05,\n});\nconst GHOST_DISAPPEAR_ANIMATION_ = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 24, 9), {\n    delay: 0.05,\n});\nconst DUDE_DISAPPEAR_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 10), {\n    delay: 0.1,\n});\nconst createDefaultUmbrellaState = () => ({\n    status: 'idle',\n    x: 4,\n    walkedInOpened: false,\n});\nconst createDefaultRainSate = () => ({\n    status: 'init',\n    drops: [],\n    delayTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(1),\n    startingTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(7),\n});\nconst createDefaultGhostState = () => ({\n    status: 'none',\n    x: 77,\n    animation: GHOST_STAND_ANIMATION.reset(),\n});\nconst createDudeDisappearState = () => ({\n    status: 'none',\n    animation: DUDE_DISAPPEAR_ANIMATION.reset(),\n});\nconst END_TIME = 4;\nfunction createDefaultActRainState() {\n    return {\n        status: 'active',\n        shake: false,\n        endTimer: new _animation__WEBPACK_IMPORTED_MODULE_0__.Timer(END_TIME),\n        dude: Object.assign(Object.assign({}, (0,_dude__WEBPACK_IMPORTED_MODULE_2__.createDefaultDudeState)()), { x: 54, direction: -1, status: 'sitting' }),\n        umbrella: createDefaultUmbrellaState(),\n        rain: createDefaultRainSate(),\n        ghost: createDefaultGhostState(),\n        dudeDisappear: createDudeDisappearState(),\n    };\n}\nfunction drawUmbrella(ctx, { state, dude }) {\n    const { x, status } = state;\n    if (status === 'idle') {\n        const rx = Math.round(x);\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.umbrella;\n        const frameWidth = 6;\n        ctx.translate(rx + frameWidth / 2, 0);\n        ctx.scale(-1, 1);\n        ctx.drawImage(image, 0, 0, 6, 19, 0, 24, 6, 19);\n        ctx.scale(-1, 1);\n        ctx.translate(-(rx + frameWidth / 2), 0);\n    }\n    if (status === 'open') {\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.umbrella;\n        const dudeRx = Math.round(dude.x);\n        const rx = dude.direction === 1 ? dudeRx + 7 : dudeRx - 7;\n        const frameWidth = 22;\n        if (dude.direction === -1) {\n            ctx.translate(rx + frameWidth / 2, 0);\n            ctx.scale(-1, 1);\n        }\n        const destX = dude.direction === -1 ? 0 : rx - frameWidth / 2;\n        ctx.drawImage(image, 10, 0, frameWidth, 19, destX, 8, frameWidth, 19);\n        if (dude.direction === -1) {\n            ctx.scale(-1, 1);\n            ctx.translate(-(rx + frameWidth / 2), 0);\n        }\n        state.x = rx;\n    }\n    if (status === 'closed') {\n        const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.umbrella;\n        const dudeRx = Math.round(dude.x);\n        const rx = dude.direction === 1 ? dudeRx + 7 : dudeRx - 7;\n        const frameWidth = 6;\n        if (dude.direction === -1) {\n            ctx.translate(rx + frameWidth / 2, 0);\n            ctx.scale(-1, 1);\n        }\n        const destX = dude.direction === -1 ? 0 : rx - frameWidth / 2;\n        ctx.drawImage(image, 0, 0, frameWidth, 19, destX, 24, frameWidth, 19);\n        if (dude.direction === -1) {\n            ctx.scale(-1, 1);\n            ctx.translate(-(rx + frameWidth / 2), 0);\n        }\n        state.x = rx;\n    }\n}\nfunction updateUmbrella({ state }) {\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Up);\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Down);\n    let { status, x } = state;\n    if (isUp && status === 'closed') {\n        status = 'open';\n    }\n    if (isDown && status === 'open') {\n        status = 'closed';\n    }\n    return Object.assign(Object.assign({}, state), { status,\n        x });\n}\nfunction drawRain(ctx, { state, umbrella, dude, }) {\n    const { status, drops, startingTimer } = state;\n    if (status === 'none') {\n        return;\n    }\n    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_5__.COLOR.A;\n    for (const [index, drop] of drops.entries()) {\n        const left = dude.direction === 1 ? dude.x - 4 : dude.x - 19;\n        const right = dude.direction === 1 ? dude.x + 17 : dude.x + 3;\n        const top = 12;\n        const bottom = 44;\n        if (status === 'starting') {\n            if ((index % Math.round(startingTimer.timeLeft) === 0 ||\n                startingTimer.timeLeft < 1) &&\n                drop.y <= bottom) {\n                if (umbrella.status === 'open' &&\n                    drop.x >= left &&\n                    drop.x <= right &&\n                    drop.y >= top &&\n                    drop.y <= bottom) {\n                    ctx.fillRect(drop.x, Math.round(drop.y), 1, 2);\n                }\n                else if (umbrella.status === 'closed' || umbrella.status === 'idle') {\n                    ctx.fillRect(drop.x, Math.round(drop.y), 1, 2);\n                }\n            }\n        }\n        if (status === 'full') {\n            if (umbrella.status === 'open' &&\n                drop.x >= left &&\n                drop.x <= right &&\n                drop.y >= top &&\n                drop.y <= bottom) {\n                ctx.fillRect(drop.x, Math.round(drop.y), 1, 2);\n            }\n            else if ((umbrella.status === 'closed' || umbrella.status === 'idle') &&\n                drop.y <= bottom) {\n                ctx.fillRect(drop.x, Math.round(drop.y), 1, 2);\n            }\n        }\n    }\n}\nfunction updateRain({ state, deltaTime, }) {\n    let { status, drops, startingTimer, delayTimer } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (drops.length === 0) {\n        for (let i = 0; i < _config__WEBPACK_IMPORTED_MODULE_5__.OW; i++) {\n            drops.push({\n                x: i,\n                y: (0,_random__WEBPACK_IMPORTED_MODULE_6__.randomNumber)(-500, _config__WEBPACK_IMPORTED_MODULE_5__.OH),\n            });\n        }\n    }\n    if (status === 'full' || status === 'starting') {\n        drops = drops.map((drop) => {\n            const yChange = (0,_random__WEBPACK_IMPORTED_MODULE_6__.randomNumber)(60, 80) * deltaTime;\n            let y = drop.y + yChange;\n            if (y > _config__WEBPACK_IMPORTED_MODULE_5__.OH) {\n                y = -5;\n            }\n            return Object.assign(Object.assign({}, drop), { y });\n        });\n    }\n    if (status === 'starting') {\n        startingTimer.update(deltaTime);\n        if (startingTimer.isDone()) {\n            status = 'full';\n        }\n    }\n    if (status === 'init') {\n        delayTimer.update(deltaTime);\n        if (delayTimer.isDone()) {\n            status = 'starting';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { drops,\n        status });\n}\nfunction drawGhost(ctx, { state, dude }) {\n    const { status, x, animation } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    let image;\n    if (status === 'idle') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.ghostWalk;\n    }\n    else if (status === 'appear' || status === 'disappear') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.ghostAppear;\n    }\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, 19, frameWidth, frameHeight);\n}\nfunction updateGhost({ state, deltaTime, }) {\n    const { status, animation } = state;\n    if (status === 'appear' || status === 'disappear') {\n        animation.update(deltaTime);\n    }\n    return state;\n}\nfunction drawDudeDisappear(ctx, { state, dude }) {\n    const { status, animation } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(dude.x);\n    const image = _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images.dudeDisappear;\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, 11, frameWidth, frameHeight);\n}\nfunction updateDudeDisappear({ state, deltaTime, }) {\n    const { status, animation } = state;\n    if (status === 'none') {\n        return state;\n    }\n    animation.update(deltaTime);\n    return state;\n}\nfunction drawActRain(ctx, { state, lastTime }) {\n    (0,_bench__WEBPACK_IMPORTED_MODULE_1__.drawBench)(ctx);\n    (0,_dude__WEBPACK_IMPORTED_MODULE_2__.drawDude)(ctx, { state: state.dude, lastTime });\n    drawUmbrella(ctx, { state: state.umbrella, dude: state.dude });\n    drawGhost(ctx, { state: state.ghost, dude: state.dude });\n    drawDudeDisappear(ctx, { state: state.dudeDisappear, dude: state.dude });\n    drawRain(ctx, {\n        state: state.rain,\n        umbrella: state.umbrella,\n        dude: state.dude,\n    });\n}\nfunction updateActRain({ state, deltaTime, }) {\n    let { dude, umbrella, rain, ghost, dudeDisappear, status, endTimer } = state;\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_4__.InputControl.Up);\n    dude = (0,_dude__WEBPACK_IMPORTED_MODULE_2__.updateDude)({ state: dude, deltaTime });\n    umbrella = updateUmbrella({ state: umbrella });\n    rain = updateRain({ state: rain, deltaTime });\n    ghost = updateGhost({ state: ghost, deltaTime });\n    dudeDisappear = updateDudeDisappear({ state: dudeDisappear, deltaTime });\n    if (rain.startingTimer.isDone() && dude.status === 'sitting' && isUp) {\n        dude.status = 'idle';\n    }\n    if (umbrella.status === 'idle' && dude.x <= 13) {\n        umbrella.status = 'closed';\n        dude.hand = 'holding-straight';\n    }\n    if (rain.status === 'full' && ghost.status === 'none') {\n        ghost.status = 'appear';\n        ghost.animation = GHOST_APPEAR_ANIMATION_SLOW.reset();\n    }\n    if ((dude.direction === 1 && dude.x >= 60 && dude.x <= 82) ||\n        (dude.direction === -1 && dude.x >= 72)) {\n        if (umbrella.status === 'closed' && ghost.status !== 'appear') {\n            ghost.status = 'appear';\n            ghost.animation = GHOST_APPEAR_ANIMATION_.reset();\n        }\n        else if (umbrella.status === 'open' && ghost.status !== 'appear') {\n            umbrella.walkedInOpened = true;\n            ghost.status = 'appear';\n            ghost.animation = GHOST_APPEAR_ANIMATION_.reset();\n        }\n        else if (umbrella.status === 'open') {\n            umbrella.walkedInOpened = true;\n        }\n        else {\n            if (umbrella.status === 'closed' && umbrella.walkedInOpened) {\n                dudeDisappear.status = 'active';\n                dude.status = 'none';\n                umbrella.status = 'idle';\n                rain.status = 'none';\n                ghost.status = 'disappear';\n                ghost.animation = GHOST_DISAPPEAR_ANIMATION_.reset();\n                endTimer.update(deltaTime);\n            }\n        }\n    }\n    else if (dudeDisappear.status === 'none') {\n        if (umbrella.status === 'open' && ghost.status !== 'disappear') {\n            ghost.status = 'disappear';\n            ghost.animation = GHOST_DISAPPEAR_ANIMATION_.reset();\n        }\n        if (umbrella.status === 'closed' && ghost.status !== 'appear') {\n            ghost.status = 'appear';\n            ghost.animation = GHOST_APPEAR_ANIMATION_.reset();\n        }\n    }\n    if (endTimer.timeLeft < END_TIME) {\n        endTimer.update(deltaTime);\n        if (endTimer.isDone()) {\n            status = 'ended';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { dude, umbrella, rain, ghost, dudeDisappear, status });\n}\n\n\n//# sourceURL=webpack:///./src/act-rain.ts?");

/***/ }),

/***/ "./src/act-smoke.ts":
/*!**************************!*\
  !*** ./src/act-smoke.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultActSmokeState\": () => (/* binding */ createDefaultActSmokeState),\n/* harmony export */   \"drawActSmoke\": () => (/* binding */ drawActSmoke),\n/* harmony export */   \"updateActSmoke\": () => (/* binding */ updateActSmoke)\n/* harmony export */ });\n/* harmony import */ var _dude__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dude */ \"./src/dude.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _bench__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bench */ \"./src/bench.ts\");\n\n\n\n\n\nconst SMOKER_WALK_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(16, 32, 3);\nconst SMOKER_SIT_DOWN_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(24, 32, 1);\nconst SMOKER_START_SMOKE_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(24, 32, 3, 1);\nconst SMOKER_SMOKING_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(24, 32, 5, 3);\nconst SMOKER_STOP_SMOKE_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(24, 32, 6, 5);\nconst SMOKER_TRANSFORM_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(16, 32, 7);\nconst CIG_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(12, 12, 2);\nconst DUDE_TRANSFORM_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(16, 32, 8);\nconst SMOKER_WALK_SPEED = 14;\nconst createDefaultSmokerState = () => ({\n    status: 'walk-to-sit',\n    animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_WALK_SHEET, { loop: true, delay: 0.16 }),\n    x: 32,\n});\nconst createDefaultCigState = () => ({\n    status: 'none',\n    animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(CIG_SHEET, { loop: true, delay: 0.3 }),\n    fallAnimation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation([1, 2, 3], { delay: 0.2 }),\n    x: 75,\n});\nconst createDefaultDudeTransformState = () => ({\n    status: 'none',\n    animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(DUDE_TRANSFORM_SHEET, { delay: 0.4 }),\n    x: 0,\n});\nfunction createDefaultActSmokeState() {\n    return {\n        status: 'active',\n        shake: false,\n        endTimer: new _animation__WEBPACK_IMPORTED_MODULE_2__.Timer(4),\n        trash: { status: 'full' },\n        dude: Object.assign(Object.assign({}, (0,_dude__WEBPACK_IMPORTED_MODULE_0__.createDefaultDudeState)()), { x: 22 }),\n        dudeTransform: createDefaultDudeTransformState(),\n        smoker: createDefaultSmokerState(),\n        cig: createDefaultCigState(),\n    };\n}\nfunction drawTrashbin(ctx, { state }) {\n    if (state.status === 'spot') {\n        ctx.drawImage(_deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.trashspot, 10, 31);\n        return;\n    }\n    ctx.drawImage(_deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.trashbin, 10, 31);\n}\nfunction drawSmoker(ctx, { state }) {\n    const { x, animation, status } = state.smoker;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    let image;\n    let destY;\n    if (status === 'walk-to-sit' || status === 'walk-away') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.smokerWalk;\n        destY = 11;\n    }\n    else if (status === 'sit-down' ||\n        status === 'start-smoke' ||\n        status === 'smoking' ||\n        status === 'stop-smoking') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.smokerSitting;\n        destY = 15;\n    }\n    else if (status === 'transform') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.smokerTransform;\n        destY = 11;\n    }\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, destY, frameWidth, frameHeight);\n}\nfunction updateSmoker({ state, dude, deltaTime, }) {\n    let { x, animation, status } = state;\n    const xChange = SMOKER_WALK_SPEED * deltaTime;\n    x += xChange;\n    if (status === 'walk-to-sit') {\n        if (x > 62) {\n            return Object.assign(Object.assign({}, state), { status: 'sit-down', animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_SIT_DOWN_SHEET, { delay: 1 }) });\n        }\n        animation.update(deltaTime);\n        return Object.assign(Object.assign({}, state), { x,\n            animation });\n    }\n    if (status === 'sit-down') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            return Object.assign(Object.assign({}, state), { status: 'start-smoke', animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_START_SMOKE_SHEET, { delay: 0.5 }) });\n        }\n        return Object.assign(Object.assign({}, state), { animation });\n    }\n    if (status === 'start-smoke') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            return Object.assign(Object.assign({}, state), { status: 'smoking', animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_SMOKING_SHEET, {\n                    loop: true,\n                    delay: 0.4,\n                }) });\n        }\n        return Object.assign(Object.assign({}, state), { animation });\n    }\n    if (status === 'smoking') {\n        if (dude.status === 'sitting') {\n            return Object.assign(Object.assign({}, state), { status: 'stop-smoking', animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_STOP_SMOKE_SHEET, {\n                    delay: 0.3,\n                }) });\n        }\n        animation.update(deltaTime);\n        return Object.assign(Object.assign({}, state), { animation });\n    }\n    if (status === 'stop-smoking') {\n        if (animation.isComplete()) {\n            return Object.assign(Object.assign({}, state), { status: 'walk-away', animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_WALK_SHEET, {\n                    loop: true,\n                    delay: 0.16,\n                }) });\n        }\n        animation.update(deltaTime);\n        return Object.assign(Object.assign({}, state), { animation });\n    }\n    if (status === 'walk-away') {\n        animation.update(deltaTime);\n        if (x > 100) {\n            return Object.assign(Object.assign({}, state), { status: 'none' });\n        }\n        return Object.assign(Object.assign({}, state), { x,\n            animation });\n    }\n    if (status === 'transform') {\n        animation.update(deltaTime);\n        if (animation.isComplete()) {\n            return Object.assign(Object.assign({}, state), { status: 'walk-to-sit', animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_WALK_SHEET, {\n                    loop: true,\n                    delay: 0.3,\n                }) });\n        }\n        return Object.assign(Object.assign({}, state), { animation });\n    }\n    return state;\n}\nfunction drawCig(ctx, { state, dude }) {\n    const { x, animation, status, fallAnimation } = state;\n    if (status === 'none' || status === 'trash') {\n        return;\n    }\n    let rx = Math.round(x);\n    let y = 33;\n    if (status === 'dude') {\n        y = 19;\n        const dudeRx = Math.round(dude.x);\n        rx = dude.direction === 1 ? dudeRx + 8 : dudeRx - 8;\n    }\n    else if (status === 'fall') {\n        y = 21 + 4 * fallAnimation.frame();\n        const dudeRx = Math.round(dude.x);\n        rx = dude.direction === 1 ? dudeRx + 8 : dudeRx - 8;\n    }\n    const image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.cig;\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    if (dude.direction === -1) {\n        ctx.translate(rx + frameWidth / 2, 0);\n        ctx.scale(-1, 1);\n    }\n    const destX = dude.direction === -1 ? 0 : rx - frameWidth / 2;\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, destX, y, frameWidth, frameHeight);\n    if (dude.direction === -1) {\n        ctx.scale(-1, 1);\n        ctx.translate(-(rx + frameWidth / 2), 0);\n    }\n}\nfunction updateCig({ state, deltaTime, }) {\n    const { animation, status, fallAnimation } = state;\n    animation.update(deltaTime);\n    if (status === 'fall') {\n        fallAnimation.update(deltaTime);\n    }\n    return Object.assign(Object.assign({}, state), { animation,\n        status });\n}\nfunction drawDudeTransform(ctx, { state, dude }) {\n    const { x, status, animation } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    const image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeTransformTrash;\n    const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n    if (dude.direction === -1) {\n        ctx.translate(rx + frameWidth / 2, 0);\n        ctx.scale(-1, 1);\n    }\n    const destX = dude.direction === -1 ? 0 : rx - frameWidth / 2;\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, destX, 11, frameWidth, frameHeight);\n    if (dude.direction === -1) {\n        ctx.scale(-1, 1);\n        ctx.translate(-(rx + frameWidth / 2), 0);\n    }\n}\nfunction updateDudeTransform({ state, deltaTime, }) {\n    let { status, animation } = state;\n    if (status === 'none') {\n        return state;\n    }\n    animation.update(deltaTime);\n    if (animation.isComplete()) {\n        status = 'done';\n    }\n    return Object.assign(Object.assign({}, state), { animation,\n        status });\n}\nfunction drawActSmoke(ctx, { state, lastTime }) {\n    (0,_bench__WEBPACK_IMPORTED_MODULE_4__.drawBench)(ctx);\n    drawTrashbin(ctx, { state: state.trash });\n    drawSmoker(ctx, { state });\n    drawCig(ctx, { state: state.cig, dude: state.dude });\n    (0,_dude__WEBPACK_IMPORTED_MODULE_0__.drawDude)(ctx, { state: state.dude, lastTime });\n    drawDudeTransform(ctx, { state: state.dudeTransform, dude: state.dude });\n}\nfunction updateActSmoke({ state, deltaTime, }) {\n    let { smoker, dude, dudeTransform, cig, trash, status, endTimer } = state;\n    smoker = updateSmoker({ state: smoker, deltaTime, dude });\n    cig = updateCig({ state: cig, deltaTime });\n    dude = (0,_dude__WEBPACK_IMPORTED_MODULE_0__.updateDude)({ state: dude, deltaTime });\n    dudeTransform = updateDudeTransform({ state: dudeTransform, deltaTime });\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up);\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down);\n    const isSittingRange = dude.x >= 47 && dude.x < 54;\n    if ((dude.status === 'walking' || dude.status === 'idle') &&\n        isDown &&\n        isSittingRange) {\n        dude.status = 'sitting';\n    }\n    if (dude.status === 'sitting' && isUp) {\n        dude.status = 'walking';\n    }\n    if (smoker.status === 'walk-away') {\n        if (cig.status === 'none') {\n            cig.status = 'ground';\n        }\n    }\n    if (cig.status === 'ground') {\n        const isPickingRange = dude.x >= 67 && dude.x < 76;\n        if (isDown && isPickingRange) {\n            dude.status = 'crouch';\n        }\n        if (dude.status === 'crouch' && isUp) {\n            cig.status = 'dude';\n            dude.status = 'walking';\n            dude.hand = 'holding-down';\n        }\n    }\n    if (cig.status === 'dude') {\n        const isTrashingRange = dude.x >= 10 && dude.x < 25;\n        if (isDown && isTrashingRange) {\n            if (trash.status === 'full') {\n                cig.status = 'none';\n                trash.status = 'spot';\n                dude.hand = 'static';\n                smoker.status = 'transform';\n                smoker.animation = new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation(SMOKER_TRANSFORM_SHEET, {\n                    delay: 0.4,\n                });\n                smoker.x = 13;\n            }\n            else if (trash.status === 'spot') {\n                cig.status = 'fall';\n                dude.status = 'none';\n                dudeTransform.status = 'active';\n                dudeTransform.x = dude.x;\n            }\n        }\n    }\n    if (dudeTransform.status === 'done') {\n        endTimer.update(deltaTime);\n        if (endTimer.isDone()) {\n            status = 'ended';\n        }\n    }\n    return Object.assign(Object.assign({}, state), { trash,\n        smoker,\n        dude,\n        dudeTransform,\n        cig,\n        status,\n        endTimer });\n}\n\n\n//# sourceURL=webpack:///./src/act-smoke.ts?");

/***/ }),

/***/ "./src/animation.ts":
/*!**************************!*\
  !*** ./src/animation.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NullAnimation\": () => (/* binding */ NullAnimation),\n/* harmony export */   \"SheetAnimation\": () => (/* binding */ SheetAnimation),\n/* harmony export */   \"Timer\": () => (/* binding */ Timer),\n/* harmony export */   \"createSheet\": () => (/* binding */ createSheet)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst DEFAULT_OPTIONS = {\n    delay: 0,\n    fps: _config__WEBPACK_IMPORTED_MODULE_0__.DRAW_FPS,\n    loop: false,\n};\nfunction createSheet(width, height, count, startIndex = 0) {\n    const sheet = [];\n    for (let i = startIndex; i < startIndex + count; i++) {\n        sheet.push([width * i, 0, width, height]);\n    }\n    return sheet;\n}\nclass SheetAnimation {\n    constructor(frames = [], options = {}) {\n        this.time = 0;\n        this.frames = frames;\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n        this.frameIndex = 0;\n        this.loopIndex = 0;\n    }\n    frame() {\n        return this.frames[this.frameIndex];\n    }\n    index() {\n        return this.frameIndex;\n    }\n    isComplete() {\n        // Looped animation can not end\n        if (this.isLoopInfinite()) {\n            return false;\n        }\n        // If loop is limited by number of times and it hasn't looped all times yet\n        // animation is not complete.\n        if (this.isLoopFinite() && !this.isLastLoop()) {\n            return false;\n        }\n        if (!this.isLastFrame()) {\n            return false;\n        }\n        // Make sure last frame is displayed on the screen for required amount\n        // of tics including delay. Only after that set animation as complete.\n        const isComplete = this.isCurrentFrameComplete();\n        return isComplete;\n    }\n    /**\n     * @param {number} deltaTime time passed since last frame in seconds\n     */\n    update(deltaTime) {\n        // Record when entire animation has started. First frame will be shown for\n        // at least one tick\n        if (this.time === 0) {\n            this.time = deltaTime;\n            return;\n        }\n        // If looping is disabled and last frame animation is complete - nothing else\n        // to animate\n        if (this.isLoopDisabled() &&\n            this.isLastFrame() &&\n            this.isCurrentFrameComplete()) {\n            return;\n        }\n        // If loop is limited to number and we are on the last loop and last frame\n        // animation is complete - nothing else to animate\n        if (this.isLoopFinite() &&\n            this.isLastLoop() &&\n            this.isLastFrame() &&\n            this.isCurrentFrameComplete()) {\n            return;\n        }\n        // Debounces animation to create a delay between frames.\n        // If enough time has not passed yet from the last animation - wait.\n        if (!this.isCurrentFrameComplete()) {\n            this.time += deltaTime;\n            return;\n        }\n        // Go to the next frame\n        this.frameIndex += 1;\n        if (this.frameIndex > this.frames.length - 1) {\n            this.frameIndex = 0;\n            // When frame is reset to the first one,\n            // consider one animation loop complete\n            this.loopIndex += 1;\n        }\n        this.time += deltaTime;\n    }\n    reset() {\n        this.frameIndex = 0;\n        this.loopIndex = 0;\n        this.time = 0;\n        return this;\n    }\n    isCurrentFrameComplete() {\n        // By default each frame will have 1 tick guaranteed\n        const minFrameTime = 1 / this.options.fps;\n        // Delay adds up to default min time\n        const singleFrameTime = minFrameTime + this.options.delay;\n        // Sum time for all frames including current in one cycle\n        const passedFramesTime = (this.loopIndex * this.frames.length + this.frameIndex + 1) *\n            singleFrameTime -\n            minFrameTime;\n        const isComplete = this.time > passedFramesTime;\n        return isComplete;\n    }\n    isLastFrame() {\n        return this.frameIndex === this.frames.length - 1;\n    }\n    isLoopInfinite() {\n        return this.options.loop === true;\n    }\n    isLoopFinite() {\n        return typeof this.options.loop === 'number';\n    }\n    isLoopDisabled() {\n        return this.options.loop === false;\n    }\n    isLastLoop() {\n        return this.loopIndex + 1 === this.options.loop;\n    }\n}\nclass NullAnimation {\n    frame() {\n        return undefined;\n    }\n    index() {\n        return 0;\n    }\n    isComplete() {\n        return false;\n    }\n    update() { }\n    reset() { }\n}\nclass Timer {\n    constructor(timeLeft = null) {\n        this.timeLeft = null;\n        this.timeLeft = timeLeft;\n    }\n    reset(timeLeft) {\n        this.timeLeft = timeLeft;\n        return this;\n    }\n    stop() {\n        this.timeLeft = null;\n        return this;\n    }\n    update(deltaTime) {\n        if (!this.isActive()) {\n            return;\n        }\n        this.timeLeft -= deltaTime;\n        if (this.timeLeft < 0) {\n            this.timeLeft = null;\n        }\n    }\n    isActive() {\n        return this.timeLeft !== null;\n    }\n    isDone() {\n        return this.timeLeft === null;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/animation.ts?");

/***/ }),

/***/ "./src/bench.ts":
/*!**********************!*\
  !*** ./src/bench.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawBench\": () => (/* binding */ drawBench)\n/* harmony export */ });\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n\nfunction drawBench(ctx) {\n    ctx.drawImage(_deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.bench, 40, 34);\n}\n\n\n//# sourceURL=webpack:///./src/bench.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COLOR\": () => (/* binding */ COLOR),\n/* harmony export */   \"DRAW_FPS\": () => (/* binding */ DRAW_FPS),\n/* harmony export */   \"IH\": () => (/* binding */ IH),\n/* harmony export */   \"IW\": () => (/* binding */ IW),\n/* harmony export */   \"OH\": () => (/* binding */ OH),\n/* harmony export */   \"OW\": () => (/* binding */ OW),\n/* harmony export */   \"RS\": () => (/* binding */ RS)\n/* harmony export */ });\nconst DRAW_FPS = 60;\nconst RS = 8; // render scale\nconst OW = 84; // original width\nconst OH = 48; // original height\nconst IW = OW * RS;\nconst IH = OH * RS;\nclass Color {\n    get A() {\n        return '#43523d';\n    }\n    get B() {\n        return '#c7f0d8';\n    }\n}\nconst COLOR = new Color();\n\n\n//# sourceURL=webpack:///./src/config.ts?");

/***/ }),

/***/ "./src/deps.ts":
/*!*********************!*\
  !*** ./src/deps.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"inputController\": () => (/* binding */ inputController),\n/* harmony export */   \"resources\": () => (/* binding */ resources)\n/* harmony export */ });\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n\nconst inputController = new _input__WEBPACK_IMPORTED_MODULE_0__.InputController();\nconst resources = {\n    images: undefined,\n};\n\n\n\n//# sourceURL=webpack:///./src/deps.ts?");

/***/ }),

/***/ "./src/dude.ts":
/*!*********************!*\
  !*** ./src/dude.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultDudeState\": () => (/* binding */ createDefaultDudeState),\n/* harmony export */   \"drawDude\": () => (/* binding */ drawDude),\n/* harmony export */   \"updateDude\": () => (/* binding */ updateDude)\n/* harmony export */ });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n\n\n\nconst WALK_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 3);\nconst SIT_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 1);\nconst CROUCH_SHEET = (0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 1);\nconst CROUCH_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation(CROUCH_SHEET);\nconst STAND_ANIMATION = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 1));\nconst CLIMB_ANIMATION_HIGH = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 2, 2), {\n    loop: true,\n    delay: 0.5,\n});\nconst CLIMB_ANIMATION_LOW = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_0__.createSheet)(16, 32, 2), {\n    loop: true,\n    delay: 0.5,\n});\nconst WALK_SPEED = 16;\nconst CLIMB_SPEED = 10;\nconst createDefaultDudeState = () => ({\n    status: 'idle',\n    head: 'static',\n    hand: 'static',\n    walking: 'active',\n    animation: STAND_ANIMATION,\n    x: 10,\n    y: 11,\n    direction: 1,\n    isUnderworld: false,\n    controllable: true,\n});\nfunction drawDude(ctx, { state, lastTime }) {\n    const { x, y, direction, animation, status, head, hand } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    const ry = Math.round(y);\n    if (status === 'climb') {\n        const image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeClimb;\n        const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n        ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, rx - frameWidth / 2, ry, frameWidth, frameHeight);\n        return;\n    }\n    const dstHeadHeight = 12;\n    let dstHeadYOff = 0;\n    let dstHandYOff = 0;\n    let srcHeadY = 12;\n    let image;\n    let destY;\n    let frame = animation.frame();\n    if (status === 'idle' || status === 'walking') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeWalk;\n        destY = 11;\n        dstHandYOff = 13;\n    }\n    else if (status === 'sitting') {\n        image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeSitting;\n        frame = SIT_SHEET[0];\n        destY = 12;\n        srcHeadY = 14;\n        dstHeadYOff = 2;\n        dstHandYOff = 15;\n    }\n    else if (status === 'crouch') {\n        frame = CROUCH_SHEET[0];\n        image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeCrouch;\n        destY = 13;\n        srcHeadY = 16;\n        dstHeadYOff = 4;\n        dstHandYOff = 17;\n    }\n    const [frameX, frameY, frameWidth, frameHeight] = frame;\n    if (direction === -1) {\n        ctx.translate(rx + frameWidth / 2, 0);\n        ctx.scale(-1, 1);\n    }\n    const destX = direction === -1 ? 0 : rx - frameWidth / 2;\n    const headImage = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeHeadBob;\n    ctx.drawImage(image, frameX, frameY + srcHeadY, frameWidth, frameHeight - dstHeadHeight, destX, destY + srcHeadY, frameWidth, frameHeight - dstHeadHeight);\n    if (head === 'static') {\n        ctx.drawImage(headImage, 0, 0, 16, 16, destX, destY + dstHeadYOff, 16, 16);\n    }\n    else if (head === 'bobbing') {\n        const srcX = Math.round(lastTime / 0.22) % 2 === 0 ? 0 : 16;\n        ctx.drawImage(headImage, srcX, 0, 16, 16, destX, destY + dstHeadYOff, 16, 16);\n    }\n    const handImage = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeHand;\n    if (hand === 'static') {\n        ctx.drawImage(handImage, 0, 0, 1, 8, destX + 5, destY + dstHandYOff, 1, 8);\n        ctx.drawImage(handImage, 0, 0, 1, 8, destX + 10, destY + dstHandYOff, 1, 8);\n    }\n    else if (hand === 'holding-down') {\n        ctx.drawImage(handImage, 0, 0, 1, 8, destX + 5, destY + dstHandYOff, 1, 8);\n        ctx.drawImage(handImage, 2, 0, 6, 8, destX + 10, destY + dstHandYOff, 6, 8);\n    }\n    else if (hand === 'holding-straight') {\n        ctx.drawImage(handImage, 0, 0, 1, 8, destX + 5, destY + dstHandYOff, 1, 8);\n        ctx.drawImage(handImage, 9, 0, 6, 8, destX + 10, destY + dstHandYOff, 6, 8);\n    }\n    if (direction === -1) {\n        ctx.scale(-1, 1);\n        ctx.translate(-(rx + frameWidth / 2), 0);\n    }\n}\nfunction updateDude({ state, deltaTime, }) {\n    let { status, x, y, direction, animation, walking, isUnderworld, controllable, } = state;\n    if (status === 'none' || status === 'sitting' || status === 'crouch') {\n        return state;\n    }\n    const isLeft = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isHold(_input__WEBPACK_IMPORTED_MODULE_2__.InputControl.Left) && controllable;\n    const isRight = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isHold(_input__WEBPACK_IMPORTED_MODULE_2__.InputControl.Right) && controllable;\n    const isUp = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isHold(_input__WEBPACK_IMPORTED_MODULE_2__.InputControl.Up) && controllable;\n    const isDown = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isHold(_input__WEBPACK_IMPORTED_MODULE_2__.InputControl.Down) && controllable;\n    if (status === 'climb') {\n        const yChange = CLIMB_SPEED * deltaTime;\n        if (isDown) {\n            animation.update(deltaTime);\n            y += yChange;\n        }\n        else if (isUp) {\n            animation.update(deltaTime);\n            y -= yChange;\n        }\n        if (isUnderworld) {\n            y = Math.min(y, 11);\n        }\n        else {\n            y = Math.max(y, 11);\n        }\n        if (isUnderworld) {\n            if (y >= 11) {\n                y = 11;\n                status = 'idle';\n            }\n        }\n        else {\n            if (y <= 11) {\n                y = 11;\n                status = 'idle';\n            }\n        }\n        if (isUnderworld) {\n            animation = CLIMB_ANIMATION_LOW;\n        }\n        else {\n            if (y < 24) {\n                animation = CLIMB_ANIMATION_HIGH;\n            }\n            else {\n                animation = CLIMB_ANIMATION_LOW;\n            }\n        }\n        return Object.assign(Object.assign({}, state), { status, y, animation });\n    }\n    const xChange = WALK_SPEED * deltaTime;\n    if (walking === 'active') {\n        if (isLeft) {\n            x -= xChange;\n            status = 'walking';\n            direction = -1;\n        }\n        else if (isRight) {\n            x += xChange;\n            status = 'walking';\n            direction = 1;\n        }\n        else {\n            status = 'idle';\n        }\n        x = Math.max(x, 0);\n        x = Math.min(x, _config__WEBPACK_IMPORTED_MODULE_3__.OW);\n        if (status === 'walking' && state.status !== 'walking') {\n            animation = new _animation__WEBPACK_IMPORTED_MODULE_0__.SheetAnimation(WALK_SHEET, { loop: true, delay: 0.12 });\n        }\n        animation.update(deltaTime);\n    }\n    if (status === 'idle') {\n        animation = STAND_ANIMATION;\n    }\n    return Object.assign(Object.assign({}, state), { status,\n        x,\n        direction,\n        animation });\n}\n\n\n//# sourceURL=webpack:///./src/dude.ts?");

/***/ }),

/***/ "./src/images.ts":
/*!***********************!*\
  !*** ./src/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImages\": () => (/* binding */ loadImages)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst IMAGES = {\n    // common - dude\n    dudeWalk: 'dude-walk-Sheet.png',\n    dudeSitting: 'dude-sitting.png',\n    dudeCrouch: 'dude-crouch.png',\n    dudeHeadBob: 'dude-head-bob.png',\n    dudeHand: 'dude-hand.png',\n    dudeClimb: 'dude-climb-Sheet.png',\n    // menu\n    bus: 'bus.png',\n    // common - env\n    bench: 'bench.png',\n    npc1Walk: 'npc1-walk-Sheet.png',\n    npc2Walk: 'npc2-walk-Sheet.png',\n    npc3Walk: 'npc3-walk-Sheet.png',\n    // common - ui\n    arrows: 'arrows.png',\n    text: 'text.png',\n    // act - intro\n    punkWalk: 'punk-walk-Sheet.png',\n    punkListen: 'punk-listen-Sheet.png',\n    punkNotes: 'punk-notes.png',\n    dudeSucked: 'dude-sucked-Sheet.png',\n    // act - smoker\n    dudeTransformTrash: 'dude-transform-trash-Sheet.png',\n    trashbin: 'trashbin.png',\n    trashspot: 'trashshop.png',\n    smokerWalk: 'smoker-walk-Sheet.png',\n    smokerSitting: 'smoker-sitting-Sheet.png',\n    smokerTransform: 'smoker-transform-Sheet.png',\n    cig: 'smoke-Sheet.png',\n    cigFall: 'cig-fall-Sheet.png',\n    // act - agent\n    agentWalk: 'agent-walk-Sheet.png',\n    // act - rain\n    umbrella: 'umbrella.png',\n    ghostWalk: 'ghost-walk-Sheet.png',\n    ghostAppear: 'ghost-appear-Sheet.png',\n    dudeDisappear: 'dude-disappear-Sheet.png',\n    // act - goose\n    gooseWalk: 'goose-walk-Sheet.png',\n    gooseScream: 'goose-scream-Sheet.png',\n    goslingWalk: 'gosling-walk-Sheet.png',\n    gosilla: 'gosilla-Sheet.png',\n    bread: 'bread.png',\n    // act - outro\n    manhole: 'manhole.png',\n    manholeAppear: 'manhole-appear-Sheet.png',\n    tree: 'tree.png',\n    midgetWalk: 'midget-Sheet.png',\n    midgetClimb: 'midget-climb-Sheet.png',\n};\nfunction loadImages() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(IMAGES).map((id) => __awaiter(this, void 0, void 0, function* () {\n            const path = `data/graphics/${IMAGES[id]}`;\n            return { id, image: yield loadImage(path) };\n        }));\n        const results = yield Promise.all(promises);\n        const map = {};\n        results.forEach(({ id, image }) => {\n            map[id] = image;\n        });\n        return map;\n    });\n}\nfunction loadImage(imagePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const image = new Image();\n            image.src = imagePath;\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/images.ts?");

/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputControl\": () => (/* binding */ InputControl),\n/* harmony export */   \"InputController\": () => (/* binding */ InputController)\n/* harmony export */ });\nvar KeyboardButtonCode;\n(function (KeyboardButtonCode) {\n    KeyboardButtonCode[KeyboardButtonCode[\"Backspace\"] = 8] = \"Backspace\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Enter\"] = 13] = \"Enter\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Esc\"] = 27] = \"Esc\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Space\"] = 32] = \"Space\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Left\"] = 37] = \"Left\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Up\"] = 38] = \"Up\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Right\"] = 39] = \"Right\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Down\"] = 40] = \"Down\";\n    KeyboardButtonCode[KeyboardButtonCode[\"W\"] = 87] = \"W\";\n    KeyboardButtonCode[KeyboardButtonCode[\"A\"] = 65] = \"A\";\n    KeyboardButtonCode[KeyboardButtonCode[\"D\"] = 68] = \"D\";\n    KeyboardButtonCode[KeyboardButtonCode[\"S\"] = 83] = \"S\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Num0\"] = 96] = \"Num0\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Num2\"] = 98] = \"Num2\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Num4\"] = 100] = \"Num4\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Num5\"] = 101] = \"Num5\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Num6\"] = 102] = \"Num6\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Num8\"] = 104] = \"Num8\";\n})(KeyboardButtonCode || (KeyboardButtonCode = {}));\n// Values are button indexes based on https://w3c.github.io/gamepad/#remapping\nvar GamepadButtonCode;\n(function (GamepadButtonCode) {\n    GamepadButtonCode[GamepadButtonCode[\"A\"] = 0] = \"A\";\n    GamepadButtonCode[GamepadButtonCode[\"B\"] = 1] = \"B\";\n    GamepadButtonCode[GamepadButtonCode[\"X\"] = 2] = \"X\";\n    GamepadButtonCode[GamepadButtonCode[\"Y\"] = 3] = \"Y\";\n    GamepadButtonCode[GamepadButtonCode[\"LeftBumper\"] = 4] = \"LeftBumper\";\n    GamepadButtonCode[GamepadButtonCode[\"RightBumper\"] = 5] = \"RightBumper\";\n    GamepadButtonCode[GamepadButtonCode[\"LeftTrigger\"] = 6] = \"LeftTrigger\";\n    GamepadButtonCode[GamepadButtonCode[\"RightTrigger\"] = 7] = \"RightTrigger\";\n    GamepadButtonCode[GamepadButtonCode[\"Select\"] = 8] = \"Select\";\n    GamepadButtonCode[GamepadButtonCode[\"Back\"] = 8] = \"Back\";\n    GamepadButtonCode[GamepadButtonCode[\"Start\"] = 9] = \"Start\";\n    GamepadButtonCode[GamepadButtonCode[\"Forward\"] = 9] = \"Forward\";\n    GamepadButtonCode[GamepadButtonCode[\"LeftStick\"] = 10] = \"LeftStick\";\n    GamepadButtonCode[GamepadButtonCode[\"RightStick\"] = 11] = \"RightStick\";\n    GamepadButtonCode[GamepadButtonCode[\"Up\"] = 12] = \"Up\";\n    GamepadButtonCode[GamepadButtonCode[\"Down\"] = 13] = \"Down\";\n    GamepadButtonCode[GamepadButtonCode[\"Left\"] = 14] = \"Left\";\n    GamepadButtonCode[GamepadButtonCode[\"Right\"] = 15] = \"Right\";\n})(GamepadButtonCode || (GamepadButtonCode = {}));\nvar MouseCode;\n(function (MouseCode) {\n    MouseCode[MouseCode[\"LeftClick\"] = 0] = \"LeftClick\";\n})(MouseCode || (MouseCode = {}));\nvar InputControl;\n(function (InputControl) {\n    InputControl[InputControl[\"Up\"] = 0] = \"Up\";\n    InputControl[InputControl[\"Down\"] = 1] = \"Down\";\n    InputControl[InputControl[\"Left\"] = 2] = \"Left\";\n    InputControl[InputControl[\"Right\"] = 3] = \"Right\";\n    InputControl[InputControl[\"Select\"] = 4] = \"Select\";\n    InputControl[InputControl[\"Back\"] = 5] = \"Back\";\n})(InputControl || (InputControl = {}));\nconst KEYBOARD_BINDING = new Map();\nKEYBOARD_BINDING.set(InputControl.Up, [\n    KeyboardButtonCode.Up,\n    KeyboardButtonCode.W,\n    KeyboardButtonCode.Num8,\n]);\nKEYBOARD_BINDING.set(InputControl.Down, [\n    KeyboardButtonCode.Down,\n    KeyboardButtonCode.S,\n    KeyboardButtonCode.Num2,\n]);\nKEYBOARD_BINDING.set(InputControl.Left, [\n    KeyboardButtonCode.Left,\n    KeyboardButtonCode.A,\n    KeyboardButtonCode.Num4,\n]);\nKEYBOARD_BINDING.set(InputControl.Right, [\n    KeyboardButtonCode.Right,\n    KeyboardButtonCode.D,\n    KeyboardButtonCode.Num6,\n]);\nKEYBOARD_BINDING.set(InputControl.Select, [\n    KeyboardButtonCode.Enter,\n    KeyboardButtonCode.Space,\n    KeyboardButtonCode.Num0,\n    KeyboardButtonCode.Num5,\n]);\nKEYBOARD_BINDING.set(InputControl.Back, [\n    KeyboardButtonCode.Esc,\n    KeyboardButtonCode.Backspace,\n]);\nconst GAMEPAD_BINDING = new Map();\nGAMEPAD_BINDING.set(InputControl.Up, [GamepadButtonCode.Up]);\nGAMEPAD_BINDING.set(InputControl.Down, [GamepadButtonCode.Down]);\nGAMEPAD_BINDING.set(InputControl.Left, [GamepadButtonCode.Left]);\nGAMEPAD_BINDING.set(InputControl.Right, [GamepadButtonCode.Right]);\nGAMEPAD_BINDING.set(InputControl.Select, [\n    GamepadButtonCode.X,\n    GamepadButtonCode.Y,\n    GamepadButtonCode.A,\n    GamepadButtonCode.B,\n]);\nGAMEPAD_BINDING.set(InputControl.Back, [\n    GamepadButtonCode.Start,\n    GamepadButtonCode.Back,\n]);\nclass KeyboardInputDevice {\n    constructor() {\n        this.listenedDownCodes = [];\n        this.downCodes = [];\n        this.holdCodes = [];\n        this.upCodes = [];\n        this.handleWindowKeyDown = (ev) => {\n            const { keyCode } = ev;\n            if (!this.listenedDownCodes.includes(keyCode)) {\n                this.listenedDownCodes.push(keyCode);\n            }\n        };\n        this.handleWindowKeyUp = (ev) => {\n            const { keyCode } = ev;\n            const index = this.listenedDownCodes.indexOf(keyCode);\n            if (index !== -1) {\n                this.listenedDownCodes.splice(index, 1);\n            }\n        };\n        this.handleWindowBlur = () => {\n            this.listenedDownCodes = [];\n        };\n    }\n    isConnected() {\n        return true;\n    }\n    listen() {\n        document.addEventListener('keydown', this.handleWindowKeyDown);\n        document.addEventListener('keyup', this.handleWindowKeyUp);\n        window.addEventListener('blur', this.handleWindowBlur);\n    }\n    unlisten() {\n        document.removeEventListener('keydown', this.handleWindowKeyDown);\n        document.removeEventListener('keyup', this.handleWindowKeyUp);\n        window.removeEventListener('blur', this.handleWindowBlur);\n    }\n    update() {\n        const codes = this.listenedDownCodes;\n        const downCodes = [];\n        const holdCodes = [];\n        for (const code of codes) {\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n            }\n            // Key that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold key continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        // Find keycodes that were down or hold on previous frame, which means\n        // that in current frame they are considered up\n        const upCodes = [];\n        for (const code of this.downCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        for (const code of this.holdCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.holdCodes = holdCodes;\n        this.upCodes = upCodes;\n    }\n    getDownCodes() {\n        return this.downCodes;\n    }\n    getHoldCodes() {\n        return this.holdCodes;\n    }\n    getUpCodes() {\n        return this.upCodes;\n    }\n}\nconst GAMEPAD_AXIS_THRESHOLD = 0.8;\nclass GamepadInputDevice {\n    constructor() {\n        this.deviceIndex = 0;\n        this.isListening = false;\n        this.downCodes = [];\n        this.holdCodes = [];\n        this.upCodes = [];\n    }\n    isConnected() {\n        const gamepad = this.getGamepad();\n        if (gamepad === null) {\n            return false;\n        }\n        return true;\n    }\n    listen() {\n        this.isListening = true;\n    }\n    unlisten() {\n        this.isListening = false;\n    }\n    update() {\n        if (!this.isListening) {\n            return;\n        }\n        const gamepad = this.getGamepad();\n        if (gamepad === null) {\n            return;\n        }\n        // Extract buttons that are in pressed state.ts\n        const codes = new Set();\n        const { buttons } = gamepad;\n        for (let i = 0; i < buttons.length; i += 1) {\n            const button = buttons[i];\n            if (button.pressed === true) {\n                codes.add(i);\n            }\n        }\n        // Convert left stick movements to left/right/up/down button presses\n        if (gamepad.axes.length >= 2) {\n            const leftStickX = gamepad.axes[0];\n            const leftStickY = gamepad.axes[1];\n            if (leftStickX < -GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Left);\n            }\n            else if (leftStickX > GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Right);\n            }\n            if (leftStickY < -GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Up);\n            }\n            else if (leftStickY > GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Down);\n            }\n        }\n        const downCodes = [];\n        const holdCodes = [];\n        for (const code of codes) {\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n            }\n            // Button that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        // Find buttons that were down or hold on previous frame, which means\n        // that in current frame they are considered up\n        const upCodes = [];\n        for (const code of this.downCodes) {\n            if (!codes.has(code)) {\n                upCodes.push(code);\n            }\n        }\n        for (const code of this.holdCodes) {\n            if (!codes.has(code)) {\n                upCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.holdCodes = holdCodes;\n        this.upCodes = upCodes;\n    }\n    getDownCodes() {\n        return this.downCodes;\n    }\n    getHoldCodes() {\n        return this.holdCodes;\n    }\n    getUpCodes() {\n        return this.upCodes;\n    }\n    getGamepad() {\n        const gamepads = navigator.getGamepads();\n        // Firefox will have empty array\n        if (gamepads.length === 0) {\n            return null;\n        }\n        const gamepad = gamepads[this.deviceIndex];\n        // Chrome will have filled array of 4 elements with null values\n        // Value will be null after device is connected or page is reloaded,\n        // until user has pressed any button.\n        if (gamepad === null) {\n            return null;\n        }\n        return gamepad;\n    }\n}\nclass MouseInput {\n    constructor() {\n        this.listenedDownCodes = [];\n        this.listenedDownPoints = [];\n        this.downCodes = [];\n        this.downPoints = [];\n        this.holdCodes = [];\n        this.listenedOverPoint = null;\n        this.overPoint = null;\n        this.handleWindowMouseDown = (ev) => {\n            const { button: code } = ev;\n            const rect = ev.target.getBoundingClientRect();\n            const x = ev.clientX - rect.left;\n            const y = ev.clientY - rect.top;\n            if (!this.listenedDownCodes.includes(code)) {\n                this.listenedDownCodes.push(code);\n                this.listenedDownPoints.push({ x, y });\n            }\n        };\n        this.handleWindowMouseUp = (ev) => {\n            const { button: code } = ev;\n            const index = this.listenedDownCodes.indexOf(code);\n            if (index !== -1) {\n                this.listenedDownCodes.splice(index, 1);\n                this.listenedDownPoints.splice(index, 1);\n            }\n        };\n        this.handleWindowMouseMove = (ev) => {\n            const rect = ev.target.getBoundingClientRect();\n            const x = ev.clientX - rect.left;\n            const y = ev.clientY - rect.top;\n            this.listenedOverPoint = { x, y };\n        };\n    }\n    listen(element) {\n        element.addEventListener('mousedown', this.handleWindowMouseDown);\n        element.addEventListener('mouseup', this.handleWindowMouseUp);\n        element.addEventListener('mousemove', this.handleWindowMouseMove);\n    }\n    update(scale) {\n        const codes = this.listenedDownCodes;\n        const points = this.listenedDownPoints;\n        const downCodes = [];\n        const downPoints = [];\n        const holdCodes = [];\n        for (const [index, code] of codes.entries()) {\n            const point = points[index];\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n                downPoints.push({ x: point.x * scale.x, y: point.y * scale.y });\n            }\n            // Key that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold key continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.downPoints = downPoints;\n        this.holdCodes = holdCodes;\n        if (this.listenedOverPoint) {\n            this.overPoint = {\n                x: this.listenedOverPoint.x * scale.x,\n                y: this.listenedOverPoint.y * scale.y,\n            };\n        }\n    }\n    isDown(code) {\n        return this.downCodes.includes(code);\n    }\n    getDownPoint(code) {\n        const index = this.downCodes.indexOf(code);\n        const point = this.downPoints[index];\n        return point;\n    }\n    getOverPoint() {\n        return this.overPoint;\n    }\n}\nclass InputMethod {\n    constructor(device, binding) {\n        this.device = device;\n        this.binding = binding;\n    }\n    isDown(control) {\n        const codes = this.unmap(control);\n        const downCodes = this.device.getDownCodes();\n        return codes.some((code) => downCodes.includes(code));\n    }\n    isHold(control) {\n        const codes = this.unmap(control);\n        const holdCodes = this.device.getHoldCodes();\n        return codes.some((code) => holdCodes.includes(code));\n    }\n    getHoldLastOf(controls) {\n        let latestIndex = -1;\n        let latestControl = undefined;\n        const holdCodes = this.device.getHoldCodes();\n        for (const control of controls) {\n            const codes = this.unmap(control);\n            for (const code of codes) {\n                const codeIndex = holdCodes.indexOf(code);\n                if (codeIndex !== -1 && codeIndex > latestIndex) {\n                    latestIndex = codeIndex;\n                    latestControl = control;\n                }\n            }\n        }\n        return latestControl;\n    }\n    unmap(control) {\n        return this.binding.get(control);\n    }\n}\nvar InputDeviceType;\n(function (InputDeviceType) {\n    InputDeviceType[InputDeviceType[\"Keyboard\"] = 0] = \"Keyboard\";\n    InputDeviceType[InputDeviceType[\"Gamepad\"] = 1] = \"Gamepad\";\n})(InputDeviceType || (InputDeviceType = {}));\nclass InputController {\n    constructor() {\n        this.methodMap = new Map();\n        this.activeDeviceType = InputDeviceType.Keyboard;\n        this.methodMap.set(InputDeviceType.Keyboard, new InputMethod(new KeyboardInputDevice(), KEYBOARD_BINDING));\n        this.methodMap.set(InputDeviceType.Gamepad, new InputMethod(new GamepadInputDevice(), GAMEPAD_BINDING));\n    }\n    isDown(control) {\n        return this.methodMap.get(this.activeDeviceType).isDown(control);\n    }\n    isHold(control) {\n        return this.methodMap.get(this.activeDeviceType).isHold(control);\n    }\n    getHoldLastOf(controls) {\n        return this.methodMap.get(this.activeDeviceType).getHoldLastOf(controls);\n    }\n    update() {\n        const activeDevice = this.methodMap.get(this.activeDeviceType).device;\n        this.methodMap.forEach((method, deviceType) => {\n            method.device.update();\n            // Check each device if it has any events. If it does, and it is not an active device - activate a new one.\n            const downCodes = method.device.getDownCodes();\n            const hasActivity = downCodes.length > 0;\n            const isSameDeviceActive = activeDevice === method.device;\n            if (hasActivity && !isSameDeviceActive) {\n                this.activeDeviceType = deviceType;\n            }\n        });\n    }\n    listen() {\n        this.methodMap.forEach((method) => {\n            method.device.listen();\n        });\n    }\n    unlisten() {\n        this.methodMap.forEach((method) => {\n            method.device.unlisten();\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./src/input.ts?");

/***/ }),

/***/ "./src/loop.ts":
/*!*********************!*\
  !*** ./src/loop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameLoop\": () => (/* binding */ GameLoop)\n/* harmony export */ });\nconst DEFAULT_OPTIONS = {\n    deltaTimeLimit: 1,\n    // requestAnimationFrame is usually 60 fps; in seconds\n    fps: 120,\n};\nvar State;\n(function (State) {\n    State[State[\"Idle\"] = 0] = \"Idle\";\n    State[State[\"Working\"] = 1] = \"Working\";\n    State[State[\"StopRequested\"] = 2] = \"StopRequested\";\n})(State || (State = {}));\nclass GameLoop {\n    constructor(options = {}) {\n        this.lastTimestamp = null;\n        this.requestedStop = false;\n        this.state = State.Idle;\n        this.loop = (timestamp = null) => {\n            var _a, _b;\n            if (this.state === State.Idle) {\n                return;\n            }\n            if (this.state === State.StopRequested) {\n                this.state = State.Idle;\n                return;\n            }\n            const idealDeltaTime = this.getIdealDeltaTime();\n            // For the very first run loop() is called from the code and timestamp is\n            // not known. On the second call loop() is called by requestAnimationFrame,\n            // which also provides a timestamp.\n            // Use ideal fixed delta value for the first run.\n            let deltaTime = idealDeltaTime;\n            if (timestamp !== null) {\n                // Timestamp is originally in milliseconds, convert to seconds\n                const deltaTimestamp = timestamp - this.lastTimestamp;\n                if (Math.round(this.getFpsInterval()) - Math.round(deltaTimestamp) > 2) {\n                    window.requestAnimationFrame(this.loop);\n                    return;\n                }\n                deltaTime = deltaTimestamp / 1000;\n                // If delta is too large, we must have resumed from stop() or breakpoint.\n                // Use ideal default delta only for this frame.\n                if (deltaTime > this.options.deltaTimeLimit) {\n                    deltaTime = idealDeltaTime;\n                }\n            }\n            this.lastTimestamp = timestamp;\n            const lastTime = timestamp / 1000;\n            (_b = (_a = this.options).onTick) === null || _b === void 0 ? void 0 : _b.call(_a, { deltaTime, lastTime });\n            window.requestAnimationFrame(this.loop);\n        };\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    }\n    start() {\n        if (this.state !== State.Idle) {\n            return;\n        }\n        this.state = State.Working;\n        this.loop();\n    }\n    // WARNING: a couple of already queued callbacks might still fire after stop\n    stop() {\n        if (this.state !== State.Working) {\n            return;\n        }\n        this.state = State.StopRequested;\n    }\n    getFpsInterval() {\n        return 1000 / this.options.fps;\n    }\n    getIdealDeltaTime() {\n        return 1 / this.options.fps;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/loop.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./images */ \"./src/images.ts\");\n/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loop */ \"./src/loop.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _act_smoke__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./act-smoke */ \"./src/act-smoke.ts\");\n/* harmony import */ var _act_intro__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./act-intro */ \"./src/act-intro.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/* harmony import */ var _act_null__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./act-null */ \"./src/act-null.ts\");\n/* harmony import */ var _act_goose__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./act-goose */ \"./src/act-goose.ts\");\n/* harmony import */ var _act_rain__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./act-rain */ \"./src/act-rain.ts\");\n/* harmony import */ var _act_outro__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./act-outro */ \"./src/act-outro.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\nconst loadingElement = document.querySelector('[data-loading]');\nconst crashElement = document.querySelector('[data-crash]');\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\ncanvas.height = _config__WEBPACK_IMPORTED_MODULE_0__.IH;\nconst loop = new _loop__WEBPACK_IMPORTED_MODULE_2__.GameLoop({ onTick: tick });\nconst state = {\n    menu: (0,_menu__WEBPACK_IMPORTED_MODULE_6__.createDefaultMenuState)({ status: 'intro' }),\n    shakeFrame: 0,\n    act: _act_null__WEBPACK_IMPORTED_MODULE_7__.defaultActNull,\n    actIndex: -1,\n    //\n    // act: createDefaultActIntroState(),\n    // actIndex: 0,\n    //\n    // act: createDefaultActSmokeState(),\n    // actIndex: 1,\n    //\n    // act: createDefaultActRainState(),\n    // actIndex: 2,\n    //\n    // act: createDefaultActGooseState(),\n    // actIndex: 3,\n    //\n    // act: createDefaultActOutroState(),\n    // actIndex: 4,\n};\n// TODO: logo, screenshots\n// TODO: 15 or 60 FPS\n// TODO: \"select act\" text in menu?\nfunction draw({ lastTime, shake = false, }) {\n    ctx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    drawBackground();\n    if (shake) {\n        const nextFrame = Math.round(lastTime / 0.2) % 2 === 0 ? 1 : 0;\n        if (state.shakeFrame !== nextFrame) {\n            if (nextFrame === 0) {\n                ctx.translate(0, 2);\n            }\n            else if (nextFrame === 1) {\n                ctx.translate(0, -2);\n            }\n            state.shakeFrame = nextFrame;\n        }\n    }\n    else {\n        if (state.shakeFrame === 1) {\n            state.shakeFrame = 0;\n            ctx.translate(0, 2);\n        }\n    }\n    const { actIndex } = state;\n    if (actIndex === 0) {\n        (0,_act_intro__WEBPACK_IMPORTED_MODULE_5__.drawActIntro)(ctx, { state: state.act, lastTime });\n    }\n    if (actIndex === 1) {\n        (0,_act_smoke__WEBPACK_IMPORTED_MODULE_4__.drawActSmoke)(ctx, { state: state.act, lastTime });\n    }\n    if (actIndex === 2) {\n        (0,_act_rain__WEBPACK_IMPORTED_MODULE_9__.drawActRain)(ctx, { state: state.act, lastTime });\n    }\n    if (actIndex === 3) {\n        (0,_act_goose__WEBPACK_IMPORTED_MODULE_8__.drawActGoose)(ctx, { state: state.act, lastTime });\n    }\n    if (actIndex === 4) {\n        (0,_act_outro__WEBPACK_IMPORTED_MODULE_10__.drawActOutro)(ctx, { state: state.act, lastTime });\n    }\n    (0,_menu__WEBPACK_IMPORTED_MODULE_6__.drawMenu)(ctx, { state: state.menu, lastTime });\n    // drawDebugGrid(ctx);\n}\nfunction drawBackground() {\n    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.COLOR.B;\n    ctx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n}\nlet lastDrawTime = 0;\nconst drawInterval = 1 / _config__WEBPACK_IMPORTED_MODULE_0__.DRAW_FPS;\nfunction tick({ deltaTime, lastTime }) {\n    _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.update();\n    let { act, menu, actIndex } = state;\n    // act = updateActIntro({ state: act as ActIntroState, deltaTime });\n    // act = updateActSmoke({ state: act as ActSmokeState, deltaTime });\n    // act = updateActRain({ state: act as ActRainState, deltaTime });\n    // act = updateActGoose({ state: act as ActGooseState, deltaTime });\n    // act = updateActOutro({ state: act as ActOutroState, deltaTime });\n    menu = (0,_menu__WEBPACK_IMPORTED_MODULE_6__.updateMenu)({ state: menu, deltaTime });\n    const { selectedIndex } = state.menu.act;\n    if (selectedIndex != null && actIndex !== selectedIndex) {\n        actIndex = selectedIndex;\n        if (actIndex === 0)\n            act = (0,_act_intro__WEBPACK_IMPORTED_MODULE_5__.createDefaultActIntroState)();\n        if (actIndex === 1)\n            act = (0,_act_smoke__WEBPACK_IMPORTED_MODULE_4__.createDefaultActSmokeState)();\n        if (actIndex === 2)\n            act = (0,_act_rain__WEBPACK_IMPORTED_MODULE_9__.createDefaultActRainState)();\n        if (actIndex === 3)\n            act = (0,_act_goose__WEBPACK_IMPORTED_MODULE_8__.createDefaultActGooseState)();\n        if (actIndex === 4)\n            act = (0,_act_outro__WEBPACK_IMPORTED_MODULE_10__.createDefaultActOutroState)();\n    }\n    if (state.menu.status === 'level' || state.menu.status === 'next') {\n        if (actIndex === 0) {\n            act = (0,_act_intro__WEBPACK_IMPORTED_MODULE_5__.updateActIntro)({ state: act, deltaTime });\n        }\n        if (actIndex === 1) {\n            act = (0,_act_smoke__WEBPACK_IMPORTED_MODULE_4__.updateActSmoke)({ state: act, deltaTime });\n        }\n        if (actIndex === 2) {\n            act = (0,_act_rain__WEBPACK_IMPORTED_MODULE_9__.updateActRain)({ state: act, deltaTime });\n        }\n        if (actIndex === 3) {\n            act = (0,_act_goose__WEBPACK_IMPORTED_MODULE_8__.updateActGoose)({ state: act, deltaTime });\n        }\n        if (actIndex === 4) {\n            act = (0,_act_outro__WEBPACK_IMPORTED_MODULE_10__.updateActOutro)({ state: act, deltaTime });\n        }\n    }\n    if (act.status === 'ended' && menu.status === 'level') {\n        menu = (0,_menu__WEBPACK_IMPORTED_MODULE_6__.createDefaultMenuState)({\n            status: 'next',\n            highlightedIndex: actIndex + 1,\n        });\n    }\n    if (menu.status === 'bus') {\n        actIndex = -1;\n        act = _act_null__WEBPACK_IMPORTED_MODULE_7__.defaultActNull;\n    }\n    state.menu = menu;\n    state.act = act;\n    state.actIndex = actIndex;\n    // Throttle the drawing but run update loop at regular FPS not to miss input events\n    const drawDeltaTime = lastTime - lastDrawTime;\n    if (drawDeltaTime > drawInterval) {\n        lastDrawTime = lastTime;\n        draw({ lastTime, shake: act.shake });\n    }\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            loadingElement.textContent = 'Loading images...';\n            _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images = yield (0,_images__WEBPACK_IMPORTED_MODULE_1__.loadImages)();\n            document.body.appendChild(canvas);\n            ctx.scale(_config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n            ctx.imageSmoothingEnabled = false;\n            _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.listen();\n            loop.start();\n        }\n        catch (err) {\n            crash();\n            console.error(err);\n        }\n        finally {\n            loadingElement.style.display = 'none';\n        }\n    });\n}\nfunction crash() {\n    loop.stop();\n    try {\n        document.body.removeChild(canvas);\n    }\n    catch (err) { }\n    crashElement.style.display = 'flex';\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDefaultMenuState\": () => (/* binding */ createDefaultMenuState),\n/* harmony export */   \"drawMenu\": () => (/* binding */ drawMenu),\n/* harmony export */   \"updateMenu\": () => (/* binding */ updateMenu)\n/* harmony export */ });\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\n\nconst BUS_STOP_X = -30;\nconst defaultBusState = {\n    status: 'drive-in',\n    x: 100,\n};\nconst defaultActState = {\n    status: 'none',\n    highlightedIndex: 0,\n    selectedIndex: undefined,\n    acts: [\n        { id: 1, isOpen: true },\n        { id: 2, isOpen: false },\n        { id: 3, isOpen: false },\n        { id: 4, isOpen: false },\n        { id: 5, isOpen: false },\n    ],\n};\nconst defaultCrowdState = { status: 'none', boys: [] };\nfunction createDefaultMenuState({ status, highlightedIndex = 0, }) {\n    if (highlightedIndex > defaultActState.acts.length - 1) {\n        highlightedIndex = 0;\n    }\n    return {\n        status,\n        bus: Object.assign({}, defaultBusState),\n        act: Object.assign(Object.assign({}, defaultActState), { highlightedIndex }),\n        crowd: Object.assign(Object.assign({}, defaultCrowdState), { boys: [] }),\n    };\n}\nfunction drawBus(ctx, { state }) {\n    const { x, status } = state;\n    if (status === 'none') {\n        return;\n    }\n    const rx = Math.round(x);\n    const image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.bus;\n    ctx.drawImage(image, rx, -9);\n}\nfunction updateBus({ state, deltaTime, }) {\n    let { x, status } = state;\n    if (status === 'none') {\n        return state;\n    }\n    if (status === 'drive-in') {\n        let speed = 40;\n        if (x < 30) {\n            speed = 30;\n        }\n        if (x < -10) {\n            speed = 20;\n        }\n        const xChange = speed * deltaTime;\n        x -= xChange;\n        if (x < BUS_STOP_X) {\n            x = BUS_STOP_X;\n            status = 'stop';\n        }\n    }\n    if (status === 'drive-out') {\n        let speed = 20;\n        if (x < -40) {\n            speed = 30;\n        }\n        if (x < -60) {\n            speed = 40;\n        }\n        const xChange = speed * deltaTime;\n        x -= xChange;\n    }\n    return Object.assign(Object.assign({}, state), { x,\n        status });\n}\nfunction drawAct(ctx, { state, lastTime }) {\n    const { highlightedIndex, acts, status } = state;\n    if (status === 'none' || status === 'chosen') {\n        return;\n    }\n    const image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.text;\n    for (const [index, act] of acts.entries()) {\n        ctx.drawImage(image, index * 4, 0, 4, 5, index * 7 + 28, 26, 4, 5);\n        if (highlightedIndex === index && Math.round(lastTime / 0.2) % 2 === 0) {\n            ctx.drawImage(image, 0, 5, 7, 8, index * 7 + 28 - 2, 24, 7, 8);\n        }\n    }\n}\nfunction updateAct({ state }) {\n    let { highlightedIndex, selectedIndex, acts, status } = state;\n    if (status === 'none' || status === 'chosen') {\n        return state;\n    }\n    const isLeft = _deps__WEBPACK_IMPORTED_MODULE_0__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_1__.InputControl.Left);\n    const isRight = _deps__WEBPACK_IMPORTED_MODULE_0__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_1__.InputControl.Right);\n    const isSelect = _deps__WEBPACK_IMPORTED_MODULE_0__.inputController.isDown(_input__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    if (isLeft && highlightedIndex > 0) {\n        highlightedIndex -= 1;\n    }\n    if (isRight && highlightedIndex < acts.length - 1) {\n        highlightedIndex += 1;\n    }\n    if (isSelect) {\n        selectedIndex = highlightedIndex;\n        status = 'chosen';\n    }\n    return Object.assign(Object.assign({}, state), { highlightedIndex,\n        selectedIndex,\n        status });\n}\nfunction drawCrowd(ctx, { state }) {\n    const { status, boys } = state;\n    if (status === 'none' || status === 'done') {\n        return;\n    }\n    for (const boy of boys) {\n        const { x, direction, animation, kind } = boy;\n        let image;\n        if (kind === 'npc1') {\n            image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.npc1Walk;\n        }\n        else if (kind === 'npc2') {\n            image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.npc2Walk;\n        }\n        else if (kind === 'npc3') {\n            image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.npc3Walk;\n        }\n        else if (kind === 'agent') {\n            image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.agentWalk;\n        }\n        else if (kind === 'smoker') {\n            image = _deps__WEBPACK_IMPORTED_MODULE_0__.resources.images.smokerWalk;\n        }\n        const rx = Math.round(x);\n        const [frameX, frameY, frameWidth, frameHeight] = animation.frame();\n        if (direction === -1) {\n            ctx.translate(rx + frameWidth / 2, 0);\n            ctx.scale(-1, 1);\n        }\n        const destX = direction === -1 ? 0 : rx - frameWidth / 2;\n        ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, destX, 12, frameWidth, frameHeight);\n        if (direction === -1) {\n            ctx.scale(-1, 1);\n            ctx.translate(-(rx + frameWidth / 2), 0);\n        }\n    }\n}\nfunction updateCrowd({ state, deltaTime, }) {\n    let { status, boys } = state;\n    if (status === 'none' || status === 'done') {\n        return state;\n    }\n    const BOYS_COUNT = 30;\n    if (boys.length === 0) {\n        for (let i = 0; i < BOYS_COUNT; i++) {\n            boys.push({\n                kind: (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElement)(['npc1', 'npc2', 'npc3', 'agent', 'smoker']),\n                x: (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(20, 40),\n                speed: (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(15, 30),\n                direction: (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElement)([1, -1]),\n                animation: new _animation__WEBPACK_IMPORTED_MODULE_2__.SheetAnimation((0,_animation__WEBPACK_IMPORTED_MODULE_2__.createSheet)(16, 32, 3), {\n                    loop: true,\n                    delay: (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElement)([0.08, 0.12, 0.16]),\n                }),\n            });\n        }\n    }\n    boys = boys.map((boy) => {\n        let { x, animation, speed, direction } = boy;\n        const xChange = speed * deltaTime;\n        x += xChange * direction;\n        animation.update(deltaTime);\n        return Object.assign(Object.assign({}, boy), { x,\n            animation });\n    });\n    const allDone = boys.every((boy) => {\n        return boy.x < -10 || boy.x > 90;\n    });\n    if (allDone) {\n        status = 'done';\n    }\n    return Object.assign(Object.assign({}, state), { boys,\n        status });\n}\nfunction drawMenu(ctx, { state, lastTime }) {\n    drawCrowd(ctx, { state: state.crowd });\n    drawBus(ctx, { state: state.bus });\n    drawAct(ctx, { state: state.act, lastTime });\n}\nfunction updateMenu({ state, deltaTime, }) {\n    let { bus, act, crowd, status } = state;\n    bus = updateBus({ state: bus, deltaTime });\n    act = updateAct({ state: act });\n    crowd = updateCrowd({ state: crowd, deltaTime });\n    if (act.status === 'chosen') {\n        status = 'intro';\n        bus.status = 'drive-out';\n    }\n    if (bus.status === 'stop') {\n        act.status = 'visible';\n        if (status === 'next') {\n            status = 'bus';\n        }\n    }\n    if (crowd.status === 'done') {\n        status = 'level';\n    }\n    if (bus.x < -70) {\n        crowd.status = 'active';\n    }\n    return Object.assign(Object.assign({}, state), { bus,\n        act,\n        crowd,\n        status });\n}\n\n\n//# sourceURL=webpack:///./src/menu.ts?");

/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"randomElement\": () => (/* binding */ randomElement),\n/* harmony export */   \"randomElementDistributed\": () => (/* binding */ randomElementDistributed),\n/* harmony export */   \"randomElements\": () => (/* binding */ randomElements),\n/* harmony export */   \"randomNumber\": () => (/* binding */ randomNumber)\n/* harmony export */ });\nfunction randomElement(items) {\n    const index = Math.floor(Math.random() * items.length);\n    return items[index];\n}\nfunction randomElementDistributed(items, distributions) {\n    const number = Math.random();\n    const index = distributions.findIndex((d) => {\n        return d > number;\n    });\n    return { item: items[index], index };\n}\nfunction randomElements(items, count) {\n    const clonedItems = items.slice();\n    const pickedItems = [];\n    for (let i = 0; i < Math.min(items.length, count); i++) {\n        const index = Math.floor(Math.random() * clonedItems.length);\n        pickedItems.push(...clonedItems.splice(index, 1));\n    }\n    return pickedItems;\n}\nfunction randomNumber(from = 0, to = 1) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n}\n\n\n//# sourceURL=webpack:///./src/random.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;