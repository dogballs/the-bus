/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/animation.ts":
/*!**************************!*\
  !*** ./src/animation.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FrameAnimation\": () => (/* binding */ FrameAnimation),\n/* harmony export */   \"NullAnimation\": () => (/* binding */ NullAnimation)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst DEFAULT_OPTIONS = {\n    delay: 0,\n    fps: _config__WEBPACK_IMPORTED_MODULE_0__.DRAW_FPS,\n    loop: false,\n};\nclass FrameAnimation {\n    constructor(frames = [], options = {}) {\n        this.time = 0;\n        this.frames = frames;\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n        this.frameIndex = 0;\n        this.loopIndex = 0;\n    }\n    frame() {\n        return this.frames[this.frameIndex];\n    }\n    index() {\n        return this.frameIndex;\n    }\n    isComplete() {\n        // Looped animation can not end\n        if (this.isLoopInfinite()) {\n            return false;\n        }\n        // If loop is limited by number of times and it hasn't looped all times yet\n        // animation is not complete.\n        if (this.isLoopFinite() && !this.isLastLoop()) {\n            return false;\n        }\n        if (!this.isLastFrame()) {\n            return false;\n        }\n        // Make sure last frame is displayed on the screen for required amount\n        // of tics including delay. Only after that set animation as complete.\n        const isComplete = this.isCurrentFrameComplete();\n        return isComplete;\n    }\n    /**\n     * @param {number} deltaTime time passed since last frame in seconds\n     */\n    update(deltaTime) {\n        // Record when entire animation has started. First frame will be shown for\n        // at least one tick\n        if (this.time === 0) {\n            this.time = deltaTime;\n            return;\n        }\n        // If looping is disabled and last frame animation is complete - nothing else\n        // to animate\n        if (this.isLoopDisabled() &&\n            this.isLastFrame() &&\n            this.isCurrentFrameComplete()) {\n            return;\n        }\n        // If loop is limited to number and we are on the last loop and last frame\n        // animation is complete - nothing else to animate\n        if (this.isLoopFinite() &&\n            this.isLastLoop() &&\n            this.isLastFrame() &&\n            this.isCurrentFrameComplete()) {\n            return;\n        }\n        // Debounces animation to create a delay between frames.\n        // If enough time has not passed yet from the last animation - wait.\n        if (!this.isCurrentFrameComplete()) {\n            this.time += deltaTime;\n            return;\n        }\n        // Go to the next frame\n        this.frameIndex += 1;\n        if (this.frameIndex > this.frames.length - 1) {\n            this.frameIndex = 0;\n            // When frame is reset to the first one,\n            // consider one animation loop complete\n            this.loopIndex += 1;\n        }\n        this.time += deltaTime;\n    }\n    reset() {\n        this.frameIndex = 0;\n        this.loopIndex = 0;\n        this.time = 0;\n        return this;\n    }\n    isCurrentFrameComplete() {\n        // By default each frame will have 1 tick guaranteed\n        const minFrameTime = 1 / this.options.fps;\n        // Delay adds up to default min time\n        const singleFrameTime = minFrameTime + this.options.delay;\n        // Sum time for all frames including current in one cycle\n        const passedFramesTime = (this.loopIndex * this.frames.length + this.frameIndex + 1) *\n            singleFrameTime -\n            minFrameTime;\n        const isComplete = this.time > passedFramesTime;\n        return isComplete;\n    }\n    isLastFrame() {\n        return this.frameIndex === this.frames.length - 1;\n    }\n    isLoopInfinite() {\n        return this.options.loop === true;\n    }\n    isLoopFinite() {\n        return typeof this.options.loop === 'number';\n    }\n    isLoopDisabled() {\n        return this.options.loop === false;\n    }\n    isLastLoop() {\n        return this.loopIndex + 1 === this.options.loop;\n    }\n}\nclass NullAnimation {\n    frame() {\n        return undefined;\n    }\n    index() {\n        return 0;\n    }\n    isComplete() {\n        return false;\n    }\n    update() { }\n    reset() { }\n}\n\n\n//# sourceURL=webpack:///./src/animation.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COLOR\": () => (/* binding */ COLOR),\n/* harmony export */   \"DRAW_FPS\": () => (/* binding */ DRAW_FPS),\n/* harmony export */   \"IH\": () => (/* binding */ IH),\n/* harmony export */   \"IW\": () => (/* binding */ IW),\n/* harmony export */   \"OH\": () => (/* binding */ OH),\n/* harmony export */   \"OW\": () => (/* binding */ OW),\n/* harmony export */   \"RS\": () => (/* binding */ RS)\n/* harmony export */ });\nconst DRAW_FPS = 15;\nconst RS = 8; // render scale\nconst OW = 84; // original width\nconst OH = 48; // original height\nconst IW = OW * RS;\nconst IH = OH * RS;\nclass Color {\n    get A() {\n        return '#43523d';\n    }\n    get B() {\n        return '#c7f0d8';\n    }\n}\nconst COLOR = new Color();\n\n\n//# sourceURL=webpack:///./src/config.ts?");

/***/ }),

/***/ "./src/debug.ts":
/*!**********************!*\
  !*** ./src/debug.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDebugGrid\": () => (/* binding */ drawDebugGrid)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawDebugGrid(ctx) {\n    ctx.strokeStyle = 'rgba(0,0,0,0.5)';\n    ctx.lineWidth = 0.1;\n    for (let i = 0; i < _config__WEBPACK_IMPORTED_MODULE_0__.OW; i++) {\n        ctx.beginPath();\n        ctx.moveTo(i, 0);\n        ctx.lineTo(i, _config__WEBPACK_IMPORTED_MODULE_0__.OH);\n        ctx.stroke();\n    }\n    for (let i = 0; i < _config__WEBPACK_IMPORTED_MODULE_0__.OH; i++) {\n        ctx.beginPath();\n        ctx.moveTo(0, i);\n        ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.OW, i);\n        ctx.stroke();\n    }\n}\n\n\n//# sourceURL=webpack:///./src/debug.ts?");

/***/ }),

/***/ "./src/deps.ts":
/*!*********************!*\
  !*** ./src/deps.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"inputController\": () => (/* binding */ inputController),\n/* harmony export */   \"resources\": () => (/* binding */ resources)\n/* harmony export */ });\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n\nconst inputController = new _input__WEBPACK_IMPORTED_MODULE_0__.InputController();\nconst resources = {\n    images: undefined,\n};\n\n\n\n//# sourceURL=webpack:///./src/deps.ts?");

/***/ }),

/***/ "./src/dude.ts":
/*!*********************!*\
  !*** ./src/dude.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultDudeState\": () => (/* binding */ defaultDudeState),\n/* harmony export */   \"drawDude\": () => (/* binding */ drawDude),\n/* harmony export */   \"updateDude\": () => (/* binding */ updateDude)\n/* harmony export */ });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n\n\n\nconst WALK_SHEET = [\n    [0, 0, 16, 32],\n    [16, 0, 16, 32],\n    [32, 0, 16, 32],\n];\nconst WALK_SPEED = 20;\nconst defaultDudeState = {\n    status: 'idle',\n    animation: new _animation__WEBPACK_IMPORTED_MODULE_0__.NullAnimation(),\n    x: 10,\n    direction: 1,\n};\nfunction drawDude(ctx, { state }) {\n    const { x, direction, animation } = state;\n    const rx = Math.round(x);\n    const image = _deps__WEBPACK_IMPORTED_MODULE_1__.resources.images.dudeWalk;\n    const frameRect = WALK_SHEET[animation.index()];\n    const [frameX, frameY, frameWidth, frameHeight] = frameRect;\n    if (direction === -1) {\n        ctx.translate(rx + frameWidth / 2, 0);\n        ctx.scale(-1, 1);\n    }\n    const destX = direction === -1 ? 0 : rx - frameWidth / 2;\n    ctx.drawImage(image, frameX, frameY, frameWidth, frameHeight, destX, 10, frameWidth, frameHeight);\n    if (direction === -1) {\n        ctx.scale(-1, 1);\n        ctx.translate(-(rx + frameWidth / 2), 0);\n    }\n}\nfunction updateDude({ state, deltaTime, }) {\n    const isLeft = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isHold(_input__WEBPACK_IMPORTED_MODULE_2__.InputControl.Left);\n    const isRight = _deps__WEBPACK_IMPORTED_MODULE_1__.inputController.isHold(_input__WEBPACK_IMPORTED_MODULE_2__.InputControl.Right);\n    let { status, x, direction, animation } = state;\n    const xChange = WALK_SPEED * deltaTime;\n    if (isLeft) {\n        x -= xChange;\n        status = 'walking';\n        direction = -1;\n    }\n    else if (isRight) {\n        x += xChange;\n        status = 'walking';\n        direction = 1;\n    }\n    else {\n        status = 'idle';\n    }\n    x = Math.max(x, 0);\n    x = Math.min(x, _config__WEBPACK_IMPORTED_MODULE_3__.OW);\n    if (status === 'walking' && state.status !== 'walking') {\n        animation = new _animation__WEBPACK_IMPORTED_MODULE_0__.FrameAnimation(WALK_SHEET, { loop: true, delay: 0.06 });\n    }\n    if (status === 'idle' && state.status !== 'idle') {\n        animation = new _animation__WEBPACK_IMPORTED_MODULE_0__.NullAnimation();\n    }\n    animation.update(deltaTime);\n    return Object.assign(Object.assign({}, state), { status,\n        x,\n        direction,\n        animation });\n}\n\n\n//# sourceURL=webpack:///./src/dude.ts?");

/***/ }),

/***/ "./src/images.ts":
/*!***********************!*\
  !*** ./src/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImages\": () => (/* binding */ loadImages)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst IMAGES = {\n    dude: 'dude.png',\n    dudeWalk: 'dude-Sheet.png',\n};\nfunction loadImages() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(IMAGES).map((id) => __awaiter(this, void 0, void 0, function* () {\n            const path = `data/graphics/${IMAGES[id]}`;\n            return { id, image: yield loadImage(path) };\n        }));\n        const results = yield Promise.all(promises);\n        const map = {};\n        results.forEach(({ id, image }) => {\n            map[id] = image;\n        });\n        return map;\n    });\n}\n;\nfunction loadImage(imagePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const image = new Image();\n            image.src = imagePath;\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/images.ts?");

/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputControl\": () => (/* binding */ InputControl),\n/* harmony export */   \"InputController\": () => (/* binding */ InputController)\n/* harmony export */ });\nvar KeyboardButtonCode;\n(function (KeyboardButtonCode) {\n    KeyboardButtonCode[KeyboardButtonCode[\"Backspace\"] = 8] = \"Backspace\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Enter\"] = 13] = \"Enter\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Esc\"] = 27] = \"Esc\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Space\"] = 32] = \"Space\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Left\"] = 37] = \"Left\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Up\"] = 38] = \"Up\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Right\"] = 39] = \"Right\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Down\"] = 40] = \"Down\";\n    KeyboardButtonCode[KeyboardButtonCode[\"W\"] = 87] = \"W\";\n    KeyboardButtonCode[KeyboardButtonCode[\"A\"] = 65] = \"A\";\n    KeyboardButtonCode[KeyboardButtonCode[\"D\"] = 68] = \"D\";\n    KeyboardButtonCode[KeyboardButtonCode[\"S\"] = 83] = \"S\";\n})(KeyboardButtonCode || (KeyboardButtonCode = {}));\n// Values are button indexes based on https://w3c.github.io/gamepad/#remapping\nvar GamepadButtonCode;\n(function (GamepadButtonCode) {\n    GamepadButtonCode[GamepadButtonCode[\"A\"] = 0] = \"A\";\n    GamepadButtonCode[GamepadButtonCode[\"B\"] = 1] = \"B\";\n    GamepadButtonCode[GamepadButtonCode[\"X\"] = 2] = \"X\";\n    GamepadButtonCode[GamepadButtonCode[\"Y\"] = 3] = \"Y\";\n    GamepadButtonCode[GamepadButtonCode[\"LeftBumper\"] = 4] = \"LeftBumper\";\n    GamepadButtonCode[GamepadButtonCode[\"RightBumper\"] = 5] = \"RightBumper\";\n    GamepadButtonCode[GamepadButtonCode[\"LeftTrigger\"] = 6] = \"LeftTrigger\";\n    GamepadButtonCode[GamepadButtonCode[\"RightTrigger\"] = 7] = \"RightTrigger\";\n    GamepadButtonCode[GamepadButtonCode[\"Select\"] = 8] = \"Select\";\n    GamepadButtonCode[GamepadButtonCode[\"Back\"] = 8] = \"Back\";\n    GamepadButtonCode[GamepadButtonCode[\"Start\"] = 9] = \"Start\";\n    GamepadButtonCode[GamepadButtonCode[\"Forward\"] = 9] = \"Forward\";\n    GamepadButtonCode[GamepadButtonCode[\"LeftStick\"] = 10] = \"LeftStick\";\n    GamepadButtonCode[GamepadButtonCode[\"RightStick\"] = 11] = \"RightStick\";\n    GamepadButtonCode[GamepadButtonCode[\"Up\"] = 12] = \"Up\";\n    GamepadButtonCode[GamepadButtonCode[\"Down\"] = 13] = \"Down\";\n    GamepadButtonCode[GamepadButtonCode[\"Left\"] = 14] = \"Left\";\n    GamepadButtonCode[GamepadButtonCode[\"Right\"] = 15] = \"Right\";\n})(GamepadButtonCode || (GamepadButtonCode = {}));\nvar MouseCode;\n(function (MouseCode) {\n    MouseCode[MouseCode[\"LeftClick\"] = 0] = \"LeftClick\";\n})(MouseCode || (MouseCode = {}));\nvar InputControl;\n(function (InputControl) {\n    InputControl[InputControl[\"Up\"] = 0] = \"Up\";\n    InputControl[InputControl[\"Down\"] = 1] = \"Down\";\n    InputControl[InputControl[\"Left\"] = 2] = \"Left\";\n    InputControl[InputControl[\"Right\"] = 3] = \"Right\";\n    InputControl[InputControl[\"Select\"] = 4] = \"Select\";\n    InputControl[InputControl[\"Back\"] = 5] = \"Back\";\n})(InputControl || (InputControl = {}));\nconst KEYBOARD_BINDING = new Map();\nKEYBOARD_BINDING.set(InputControl.Up, [\n    KeyboardButtonCode.Up,\n    KeyboardButtonCode.W,\n]);\nKEYBOARD_BINDING.set(InputControl.Down, [\n    KeyboardButtonCode.Down,\n    KeyboardButtonCode.S,\n]);\nKEYBOARD_BINDING.set(InputControl.Left, [\n    KeyboardButtonCode.Left,\n    KeyboardButtonCode.A,\n]);\nKEYBOARD_BINDING.set(InputControl.Right, [\n    KeyboardButtonCode.Right,\n    KeyboardButtonCode.D,\n]);\nKEYBOARD_BINDING.set(InputControl.Select, [\n    KeyboardButtonCode.Enter,\n    KeyboardButtonCode.Space,\n]);\nKEYBOARD_BINDING.set(InputControl.Back, [\n    KeyboardButtonCode.Esc,\n    KeyboardButtonCode.Backspace,\n]);\nconst GAMEPAD_BINDING = new Map();\nGAMEPAD_BINDING.set(InputControl.Up, [GamepadButtonCode.Up]);\nGAMEPAD_BINDING.set(InputControl.Down, [GamepadButtonCode.Down]);\nGAMEPAD_BINDING.set(InputControl.Left, [GamepadButtonCode.Left]);\nGAMEPAD_BINDING.set(InputControl.Right, [GamepadButtonCode.Right]);\nGAMEPAD_BINDING.set(InputControl.Select, [\n    GamepadButtonCode.X,\n    GamepadButtonCode.Y,\n    GamepadButtonCode.A,\n    GamepadButtonCode.B,\n]);\nGAMEPAD_BINDING.set(InputControl.Back, [\n    GamepadButtonCode.Start,\n    GamepadButtonCode.Back,\n]);\nclass KeyboardInputDevice {\n    constructor() {\n        this.listenedDownCodes = [];\n        this.downCodes = [];\n        this.holdCodes = [];\n        this.upCodes = [];\n        this.handleWindowKeyDown = (ev) => {\n            const { keyCode } = ev;\n            if (!this.listenedDownCodes.includes(keyCode)) {\n                this.listenedDownCodes.push(keyCode);\n            }\n        };\n        this.handleWindowKeyUp = (ev) => {\n            const { keyCode } = ev;\n            const index = this.listenedDownCodes.indexOf(keyCode);\n            if (index !== -1) {\n                this.listenedDownCodes.splice(index, 1);\n            }\n        };\n        this.handleWindowBlur = () => {\n            this.listenedDownCodes = [];\n        };\n    }\n    isConnected() {\n        return true;\n    }\n    listen() {\n        document.addEventListener('keydown', this.handleWindowKeyDown);\n        document.addEventListener('keyup', this.handleWindowKeyUp);\n        window.addEventListener('blur', this.handleWindowBlur);\n    }\n    unlisten() {\n        document.removeEventListener('keydown', this.handleWindowKeyDown);\n        document.removeEventListener('keyup', this.handleWindowKeyUp);\n        window.removeEventListener('blur', this.handleWindowBlur);\n    }\n    update() {\n        const codes = this.listenedDownCodes;\n        const downCodes = [];\n        const holdCodes = [];\n        for (const code of codes) {\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n            }\n            // Key that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold key continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        // Find keycodes that were down or hold on previous frame, which means\n        // that in current frame they are considered up\n        const upCodes = [];\n        for (const code of this.downCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        for (const code of this.holdCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.holdCodes = holdCodes;\n        this.upCodes = upCodes;\n    }\n    getDownCodes() {\n        return this.downCodes;\n    }\n    getHoldCodes() {\n        return this.holdCodes;\n    }\n    getUpCodes() {\n        return this.upCodes;\n    }\n}\nconst GAMEPAD_AXIS_THRESHOLD = 0.8;\nclass GamepadInputDevice {\n    constructor() {\n        this.deviceIndex = 0;\n        this.isListening = false;\n        this.downCodes = [];\n        this.holdCodes = [];\n        this.upCodes = [];\n    }\n    isConnected() {\n        const gamepad = this.getGamepad();\n        if (gamepad === null) {\n            return false;\n        }\n        return true;\n    }\n    listen() {\n        this.isListening = true;\n    }\n    unlisten() {\n        this.isListening = false;\n    }\n    update() {\n        if (!this.isListening) {\n            return;\n        }\n        const gamepad = this.getGamepad();\n        if (gamepad === null) {\n            return;\n        }\n        // Extract buttons that are in pressed state.ts\n        const codes = new Set();\n        const { buttons } = gamepad;\n        for (let i = 0; i < buttons.length; i += 1) {\n            const button = buttons[i];\n            if (button.pressed === true) {\n                codes.add(i);\n            }\n        }\n        // Convert left stick movements to left/right/up/down button presses\n        if (gamepad.axes.length >= 2) {\n            const leftStickX = gamepad.axes[0];\n            const leftStickY = gamepad.axes[1];\n            if (leftStickX < -GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Left);\n            }\n            else if (leftStickX > GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Right);\n            }\n            if (leftStickY < -GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Up);\n            }\n            else if (leftStickY > GAMEPAD_AXIS_THRESHOLD) {\n                codes.add(GamepadButtonCode.Down);\n            }\n        }\n        const downCodes = [];\n        const holdCodes = [];\n        for (const code of codes) {\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n            }\n            // Button that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        // Find buttons that were down or hold on previous frame, which means\n        // that in current frame they are considered up\n        const upCodes = [];\n        for (const code of this.downCodes) {\n            if (!codes.has(code)) {\n                upCodes.push(code);\n            }\n        }\n        for (const code of this.holdCodes) {\n            if (!codes.has(code)) {\n                upCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.holdCodes = holdCodes;\n        this.upCodes = upCodes;\n    }\n    getDownCodes() {\n        return this.downCodes;\n    }\n    getHoldCodes() {\n        return this.holdCodes;\n    }\n    getUpCodes() {\n        return this.upCodes;\n    }\n    getGamepad() {\n        const gamepads = navigator.getGamepads();\n        // Firefox will have empty array\n        if (gamepads.length === 0) {\n            return null;\n        }\n        const gamepad = gamepads[this.deviceIndex];\n        // Chrome will have filled array of 4 elements with null values\n        // Value will be null after device is connected or page is reloaded,\n        // until user has pressed any button.\n        if (gamepad === null) {\n            return null;\n        }\n        return gamepad;\n    }\n}\nclass MouseInput {\n    constructor() {\n        this.listenedDownCodes = [];\n        this.listenedDownPoints = [];\n        this.downCodes = [];\n        this.downPoints = [];\n        this.holdCodes = [];\n        this.listenedOverPoint = null;\n        this.overPoint = null;\n        this.handleWindowMouseDown = (ev) => {\n            const { button: code } = ev;\n            const rect = ev.target.getBoundingClientRect();\n            const x = ev.clientX - rect.left;\n            const y = ev.clientY - rect.top;\n            if (!this.listenedDownCodes.includes(code)) {\n                this.listenedDownCodes.push(code);\n                this.listenedDownPoints.push({ x, y });\n            }\n        };\n        this.handleWindowMouseUp = (ev) => {\n            const { button: code } = ev;\n            const index = this.listenedDownCodes.indexOf(code);\n            if (index !== -1) {\n                this.listenedDownCodes.splice(index, 1);\n                this.listenedDownPoints.splice(index, 1);\n            }\n        };\n        this.handleWindowMouseMove = (ev) => {\n            const rect = ev.target.getBoundingClientRect();\n            const x = ev.clientX - rect.left;\n            const y = ev.clientY - rect.top;\n            this.listenedOverPoint = { x, y };\n        };\n    }\n    listen(element) {\n        element.addEventListener('mousedown', this.handleWindowMouseDown);\n        element.addEventListener('mouseup', this.handleWindowMouseUp);\n        element.addEventListener('mousemove', this.handleWindowMouseMove);\n    }\n    update(scale) {\n        const codes = this.listenedDownCodes;\n        const points = this.listenedDownPoints;\n        const downCodes = [];\n        const downPoints = [];\n        const holdCodes = [];\n        for (const [index, code] of codes.entries()) {\n            const point = points[index];\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n                downPoints.push({ x: point.x * scale.x, y: point.y * scale.y });\n            }\n            // Key that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold key continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.downPoints = downPoints;\n        this.holdCodes = holdCodes;\n        if (this.listenedOverPoint) {\n            this.overPoint = {\n                x: this.listenedOverPoint.x * scale.x,\n                y: this.listenedOverPoint.y * scale.y,\n            };\n        }\n    }\n    isDown(code) {\n        return this.downCodes.includes(code);\n    }\n    getDownPoint(code) {\n        const index = this.downCodes.indexOf(code);\n        const point = this.downPoints[index];\n        return point;\n    }\n    getOverPoint() {\n        return this.overPoint;\n    }\n}\nclass InputMethod {\n    constructor(device, binding) {\n        this.device = device;\n        this.binding = binding;\n    }\n    isDown(control) {\n        const codes = this.unmap(control);\n        const downCodes = this.device.getDownCodes();\n        return codes.some((code) => downCodes.includes(code));\n    }\n    isHold(control) {\n        const codes = this.unmap(control);\n        const holdCodes = this.device.getHoldCodes();\n        return codes.some((code) => holdCodes.includes(code));\n    }\n    getHoldLastOf(controls) {\n        let latestIndex = -1;\n        let latestControl = undefined;\n        const holdCodes = this.device.getHoldCodes();\n        for (const control of controls) {\n            const codes = this.unmap(control);\n            for (const code of codes) {\n                const codeIndex = holdCodes.indexOf(code);\n                if (codeIndex !== -1 && codeIndex > latestIndex) {\n                    latestIndex = codeIndex;\n                    latestControl = control;\n                }\n            }\n        }\n        return latestControl;\n    }\n    unmap(control) {\n        return this.binding.get(control);\n    }\n}\nvar InputDeviceType;\n(function (InputDeviceType) {\n    InputDeviceType[InputDeviceType[\"Keyboard\"] = 0] = \"Keyboard\";\n    InputDeviceType[InputDeviceType[\"Gamepad\"] = 1] = \"Gamepad\";\n})(InputDeviceType || (InputDeviceType = {}));\nclass InputController {\n    constructor() {\n        this.methodMap = new Map();\n        this.activeDeviceType = InputDeviceType.Keyboard;\n        this.methodMap.set(InputDeviceType.Keyboard, new InputMethod(new KeyboardInputDevice(), KEYBOARD_BINDING));\n        this.methodMap.set(InputDeviceType.Gamepad, new InputMethod(new GamepadInputDevice(), GAMEPAD_BINDING));\n    }\n    isDown(control) {\n        return this.methodMap.get(this.activeDeviceType).isDown(control);\n    }\n    isHold(control) {\n        return this.methodMap.get(this.activeDeviceType).isHold(control);\n    }\n    getHoldLastOf(controls) {\n        return this.methodMap.get(this.activeDeviceType).getHoldLastOf(controls);\n    }\n    update() {\n        const activeDevice = this.methodMap.get(this.activeDeviceType).device;\n        this.methodMap.forEach((method, deviceType) => {\n            method.device.update();\n            // Check each device if it has any events. If it does, and it is not an active device - activate a new one.\n            const downCodes = method.device.getDownCodes();\n            const hasActivity = downCodes.length > 0;\n            const isSameDeviceActive = activeDevice === method.device;\n            if (hasActivity && !isSameDeviceActive) {\n                this.activeDeviceType = deviceType;\n            }\n        });\n    }\n    listen() {\n        this.methodMap.forEach((method) => {\n            method.device.listen();\n        });\n    }\n    unlisten() {\n        this.methodMap.forEach((method) => {\n            method.device.unlisten();\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./src/input.ts?");

/***/ }),

/***/ "./src/loop.ts":
/*!*********************!*\
  !*** ./src/loop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameLoop\": () => (/* binding */ GameLoop)\n/* harmony export */ });\nconst DEFAULT_OPTIONS = {\n    deltaTimeLimit: 1,\n    // requestAnimationFrame is usually 60 fps; in seconds\n    fps: 120,\n};\nvar State;\n(function (State) {\n    State[State[\"Idle\"] = 0] = \"Idle\";\n    State[State[\"Working\"] = 1] = \"Working\";\n    State[State[\"StopRequested\"] = 2] = \"StopRequested\";\n})(State || (State = {}));\nclass GameLoop {\n    constructor(options = {}) {\n        this.lastTimestamp = null;\n        this.requestedStop = false;\n        this.state = State.Idle;\n        this.loop = (timestamp = null) => {\n            var _a, _b;\n            if (this.state === State.Idle) {\n                return;\n            }\n            if (this.state === State.StopRequested) {\n                this.state = State.Idle;\n                return;\n            }\n            const idealDeltaTime = this.getIdealDeltaTime();\n            // For the very first run loop() is called from the code and timestamp is\n            // not known. On the second call loop() is called by requestAnimationFrame,\n            // which also provides a timestamp.\n            // Use ideal fixed delta value for the first run.\n            let deltaTime = idealDeltaTime;\n            if (timestamp !== null) {\n                // Timestamp is originally in milliseconds, convert to seconds\n                const deltaTimestamp = timestamp - this.lastTimestamp;\n                if (Math.round(this.getFpsInterval()) - Math.round(deltaTimestamp) > 2) {\n                    window.requestAnimationFrame(this.loop);\n                    return;\n                }\n                deltaTime = deltaTimestamp / 1000;\n                // If delta is too large, we must have resumed from stop() or breakpoint.\n                // Use ideal default delta only for this frame.\n                if (deltaTime > this.options.deltaTimeLimit) {\n                    deltaTime = idealDeltaTime;\n                }\n            }\n            this.lastTimestamp = timestamp;\n            const lastTime = timestamp / 1000;\n            (_b = (_a = this.options).onTick) === null || _b === void 0 ? void 0 : _b.call(_a, { deltaTime, lastTime });\n            window.requestAnimationFrame(this.loop);\n        };\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    }\n    start() {\n        if (this.state !== State.Idle) {\n            return;\n        }\n        this.state = State.Working;\n        this.loop();\n    }\n    // WARNING: a couple of already queued callbacks might still fire after stop\n    stop() {\n        if (this.state !== State.Working) {\n            return;\n        }\n        this.state = State.StopRequested;\n    }\n    getFpsInterval() {\n        return 1000 / this.options.fps;\n    }\n    getIdealDeltaTime() {\n        return 1 / this.options.fps;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/loop.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./images */ \"./src/images.ts\");\n/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loop */ \"./src/loop.ts\");\n/* harmony import */ var _deps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deps */ \"./src/deps.ts\");\n/* harmony import */ var _dude__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dude */ \"./src/dude.ts\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug */ \"./src/debug.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst loadingElement = document.querySelector('[data-loading]');\nconst crashElement = document.querySelector('[data-crash]');\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\ncanvas.height = _config__WEBPACK_IMPORTED_MODULE_0__.IH;\nconst loop = new _loop__WEBPACK_IMPORTED_MODULE_2__.GameLoop({ onTick: tick });\nconst state = {\n    dude: _dude__WEBPACK_IMPORTED_MODULE_4__.defaultDudeState,\n};\nfunction draw({ lastTime }) {\n    ctx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    drawBackground();\n    (0,_debug__WEBPACK_IMPORTED_MODULE_5__.drawDebugGrid)(ctx);\n    (0,_dude__WEBPACK_IMPORTED_MODULE_4__.drawDude)(ctx, { state: state.dude });\n}\nfunction drawBackground() {\n    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.COLOR.B;\n    ctx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n}\nlet lastDrawTime = 0;\nconst drawInterval = 1 / _config__WEBPACK_IMPORTED_MODULE_0__.DRAW_FPS;\n// Throttle the drawing but run update loop at regular FPS not to miss input events\nfunction tick({ deltaTime, lastTime }) {\n    _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.update();\n    state.dude = (0,_dude__WEBPACK_IMPORTED_MODULE_4__.updateDude)({ state: state.dude, deltaTime });\n    const drawDeltaTime = lastTime - lastDrawTime;\n    if (drawDeltaTime > drawInterval) {\n        lastDrawTime = lastTime;\n        draw({ lastTime });\n    }\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            loadingElement.textContent = 'Loading images...';\n            _deps__WEBPACK_IMPORTED_MODULE_3__.resources.images = yield (0,_images__WEBPACK_IMPORTED_MODULE_1__.loadImages)();\n            document.body.appendChild(canvas);\n            ctx.scale(_config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n            ctx.imageSmoothingEnabled = false;\n            _deps__WEBPACK_IMPORTED_MODULE_3__.inputController.listen();\n            loop.start();\n        }\n        catch (err) {\n            crash();\n            console.error(err);\n        }\n        finally {\n            loadingElement.style.display = 'none';\n        }\n    });\n}\nfunction crash() {\n    loop.stop();\n    try {\n        document.body.removeChild(canvas);\n    }\n    catch (err) { }\n    crashElement.style.display = 'flex';\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;